From 497bc6d283dcdf854e65979e7ca4666c216e3fd8 Mon Sep 17 00:00:00 2001
From: Roman Beranek <roman.beranek@prusa3d.com>
Date: Tue, 17 Dec 2019 10:56:45 +0100
Subject: [PATCH] prusa64-sl1: work around mistakenly written eFUSEs

Earlier kernel code work under an assumption that the eFUSEs
are stored in big endian fashion and thus each word read must
have the order of its bytes reversed.

This was later proven to be untrue and the devs decided to
fix it. Meanwhile, thousands of our boards have their eFuses
already burnt out and so this recent change kind of fucks it
up for us.

This fix a) reverts back to reversing the byte-order of words
read from the eFUSES and b) gives the thermal driver ability
to reverse already reversed data back to its native form.
---
 drivers/nvmem/sunxi_sid.c                     | 8 ++++++--
 drivers/thermal/sun8i_thermal.c               | 9 +++++++--
 2 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/drivers/nvmem/sunxi_sid.c b/drivers/nvmem/sunxi_sid.c
index e26ef1bbf198..4fc095a92c94 100644
--- a/drivers/nvmem/sunxi_sid.c
+++ b/drivers/nvmem/sunxi_sid.c
@@ -65,8 +65,10 @@ static int sun8i_sid_register_readout(const struct sunxi_sid *sid,
 	if (ret)
 		return ret;
 
-	if (out)
+	if (out) {
 		*out = readl(sid->base + SUN8I_SID_RDKEY);
+		be32_to_cpus(out);
+	}
 
 	writel(0, sid->base + SUN8I_SID_PRCTL);
 
@@ -87,10 +89,12 @@ static int sun8i_sid_read_by_reg(void *context, unsigned int offset,
 
 	/* .stride = 4 so offset is guaranteed to be aligned */
 	while (bytes >= 4) {
-		ret = sun8i_sid_register_readout(sid, offset, val);
+		ret = sun8i_sid_register_readout(sid, offset, &word);
 		if (ret)
 			return ret;
 
+		memcpy(val, &word, 4);
+
 		val += 4;
 		offset += 4;
 		bytes -= 4;
diff --git a/drivers/thermal/sun8i_thermal.c b/drivers/thermal/sun8i_thermal.c
index 0de9a56c3775..b5ad52754817 100644
--- a/drivers/thermal/sun8i_thermal.c
+++ b/drivers/thermal/sun8i_thermal.c
@@ -287,7 +287,7 @@ static int sun8i_ths_calibrate(struct ths_device *tmdev)
 {
 	struct nvmem_cell *calcell;
 	struct device *dev = tmdev->dev;
-	u16 *caldata;
+	u8 *caldata;
 	size_t callen;
 	int ret = 0;
 
@@ -317,7 +317,13 @@ static int sun8i_ths_calibrate(struct ths_device *tmdev)
 		goto out;
 	}
 
-	tmdev->chip->calibrate(tmdev, caldata, callen);
+	if (callen == 8 && tmdev->chip->sensor_num == 3
+	    && ((u16*)caldata)[2] == 0) {
+		be32_to_cpus((u32*)caldata);
+		be32_to_cpus((u32*)caldata + 1);
+	}
+
+	tmdev->chip->calibrate(tmdev, (u16*)caldata, callen);
 
 	kfree(caldata);
 out:
-- 
2.24.1

