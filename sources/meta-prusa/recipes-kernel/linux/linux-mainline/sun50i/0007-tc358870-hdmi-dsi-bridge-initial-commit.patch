From c75ebe7b4305d0499d56dca9c8b56617259240aa Mon Sep 17 00:00:00 2001
From: Filip Kotoucek <filip.kotoucek@prusa3d.cz>
Date: Tue, 13 Nov 2018 11:38:49 +0100
Subject: [PATCH 18/79] tc358870: hdmi->dsi bridge initial commit

---
 drivers/gpu/drm/bridge/Kconfig    |   9 +
 drivers/gpu/drm/bridge/Makefile   |   1 +
 drivers/gpu/drm/bridge/tc358870.c | 677 ++++++++++++++++++++++++++++++
 drivers/gpu/drm/drm_edid_load.c   |  22 +-
 4 files changed, 709 insertions(+), 1 deletion(-)
 create mode 100644 drivers/gpu/drm/bridge/tc358870.c
 
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 1cc9f502c1f2..0e763a946572 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -133,6 +133,15 @@ config DRM_TOSHIBA_TC358767
 	---help---
 	  Toshiba TC358767 eDP bridge chip driver.
 
+config DRM_TOSHIBA_TC358870
+	tristate "Toshiba TC358870 HDMI->DSI bridge"
+	depends on OF
+	select DRM_KMS_HELPER
+	select REGMAP_I2C
+	select DRM_PANEL
+	---help---
+	  Toshiba TC358870 HDMI->DSI bridge chip driver.
+
 config DRM_TI_TFP410
 	tristate "TI TFP410 DVI/HDMI bridge"
 	depends on OF
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 4934fcf5a6f8..e881ec105c0f 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_DRM_SII9234) += sii9234.o
 obj-$(CONFIG_DRM_THINE_THC63LVD1024) += thc63lvd1024.o
 obj-$(CONFIG_DRM_TOSHIBA_TC358764) += tc358764.o
 obj-$(CONFIG_DRM_TOSHIBA_TC358767) += tc358767.o
+obj-$(CONFIG_DRM_TOSHIBA_TC358870) += tc358870.o
 obj-$(CONFIG_DRM_ANALOGIX_DP) += analogix/
 obj-$(CONFIG_DRM_I2C_ADV7511) += adv7511/
 obj-$(CONFIG_DRM_TI_SN65DSI86) += ti-sn65dsi86.o
diff --git a/drivers/gpu/drm/bridge/tc358870.c b/drivers/gpu/drm/bridge/tc358870.c
new file mode 100644
index 000000000000..04cdef337061
--- /dev/null
+++ b/drivers/gpu/drm/bridge/tc358870.c
@@ -0,0 +1,677 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2018, Filip Kotoucek
+ */
+
+#define DEBUG
+
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/hrtimer.h>
+#include <linux/sched.h>
+
+#include <drm/drm_bridge.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_edid.h>
+
+#define REG_CHIP_ID			0x00, 0x00
+#define REG_SYS_CTL			0x00, 0x02
+#define REG_CONF_CTL_0		0x00, 0x04
+#define REG_CONF_CTL_1		0x00, 0x06
+
+#define REG_SYS_STATUS		0x85, 0x20
+#define SYS_STATUS_DDC5V	0x01
+#define SYS_STATUS_SYNC		0x8F
+
+//pause communication usleep_range(tc358870_msg.len, tc358870_msg.len + 1000)
+#define USLEEP_PAUSE		0xFF
+
+struct tc358870_msg
+{
+	char data[8];
+	int len;
+};
+
+struct tc358870 {
+	struct i2c_client *client;
+	struct drm_bridge bridge;
+	struct drm_connector connector;
+	struct device *device;
+
+	struct gpio_desc *tc358870_reset;
+	struct gpio_desc *lcd_reset;
+
+	struct regulator *vdd12_mipi_supply;
+	struct regulator *vdd11_hdmi_supply;
+	struct regulator *avdd_lcd_supply;
+	struct regulator *iovdd_lcd_supply;
+
+	struct mutex lock; /* Protects fields below and device registers */
+};
+
+/*
+ * data are sent LSB first
+ * data are shifted into internal registers in following order:
+ *		data[7:0], data[15:8], data[23:16], data[31:24]
+ */
+struct tc358870_msg tc358870_init_data[] = {
+		{{0x00, 0x04, 0x04, 0x00}, 4},
+		{{0x00, 0x02, 0x01, 0x3F}, 4},
+		{{0x00, 0x02, 0x00, 0x00}, 4},
+		{{0x00, 0x06,	0x08, 0x00}, 4},
+		{{0x84, 0x10, 0x03}, 3},            //PHY_CTL Linked with DDC5V detection
+		{{0x84, 0x13, 0x3F}, 3},
+		{{0x84, 0xF0, 0x31}, 3},
+		{{0x84, 0xF4, 0x01}, 3},            //DDCIO
+		{{0x85, 0x40, 0xC0, 0x12}, 4},      //SYS_FREQ0 refclk setting 48 MHz
+		//{{0x85, 0x40, 0x88, 0x13}, 4},    //SYS_FREQ0 refclk setting 50 MHz
+		{{0x86, 0x30, 0x00}, 3},
+		{{0x86, 0x31, 0x53, 0x07}, 4},
+		{{0x86, 0x70, 0x02}, 3},
+		{{0x8A, 0x0C, 0xC0, 0x12}, 4},      //SCLK_CSC0 refclk setting 48 MHz
+		//{{0x8A, 0x0C, 0x88, 0x13}, 4},    //SCLK_CSC0 refclk setting 50 MHz
+		{{0x85, 0x02, 0xFF}, 3},            //SYS_INTERRUPT
+		{{0x85, 0x12, 0xFE}, 3},
+		{{0x85, 0x14, 0x00}, 3},
+		{{0x85, 0x15, 0x00}, 3},
+		{{0x85, 0x16, 0x00}, 3},
+		{{0x00, 0x14, 0xBF, 0x0F}, 4},
+		{{0x00, 0x16, 0xFF, 0x0F}, 4},
+
+		{{0x85, 0xE0, 0x01}, 3},            //EDID_MODE
+		{{0x85, 0xE3, 0x80, 0x00}, 4},      //EDID_LEN Roman 128 B
+		{{0x8C, 0x00, 0x00}, 3},
+		{{0x8C, 0x01, 0xff}, 3},
+		{{0x8C, 0x02, 0xff}, 3},
+		{{0x8C, 0x03, 0xff}, 3},
+		{{0x8C, 0x04, 0xff}, 3},
+		{{0x8C, 0x05, 0xff}, 3},
+		{{0x8C, 0x06, 0xff}, 3},
+		{{0x8C, 0x07, 0x00}, 3},
+		{{0x8C, 0x08, 0x52}, 3},
+		{{0x8C, 0x09, 0x62}, 3},
+		{{0x8C, 0x0A, 0x88}, 3},
+		{{0x8C, 0x0B, 0x88}, 3},
+		{{0x8C, 0x0C, 0xa4}, 3},
+		{{0x8C, 0x0D, 0x01}, 3},
+		{{0x8C, 0x0E, 0x00}, 3},
+		{{0x8C, 0x0F, 0x00}, 3},
+		{{0x8C, 0x10, 0x1c}, 3},
+		{{0x8C, 0x11, 0x15}, 3},
+		{{0x8C, 0x12, 0x01}, 3},
+		{{0x8C, 0x13, 0x03}, 3},
+		{{0x8C, 0x14, 0x81}, 3},
+		{{0x8C, 0x15, 0x10}, 3},
+		{{0x8C, 0x16, 0x09}, 3},
+		{{0x8C, 0x17, 0x78}, 3},
+		{{0x8C, 0x18, 0x0a}, 3},
+		{{0x8C, 0x19, 0xda}, 3},
+		{{0x8C, 0x1A, 0xff}, 3},
+		{{0x8C, 0x1B, 0xa3}, 3},
+		{{0x8C, 0x1C, 0x58}, 3},
+		{{0x8C, 0x1D, 0x4a}, 3},
+		{{0x8C, 0x1E, 0xa2}, 3},
+		{{0x8C, 0x1F, 0x29}, 3},
+		{{0x8C, 0x20, 0x17}, 3},
+		{{0x8C, 0x21, 0x49}, 3},
+		{{0x8C, 0x22, 0x4b}, 3},
+		{{0x8C, 0x23, 0x00}, 3},
+		{{0x8C, 0x24, 0x00}, 3},
+		{{0x8C, 0x25, 0x00}, 3},
+		{{0x8C, 0x26, 0x01}, 3},
+		{{0x8C, 0x27, 0x01}, 3},
+		{{0x8C, 0x28, 0x01}, 3},
+		{{0x8C, 0x29, 0x01}, 3},
+		{{0x8C, 0x2A, 0x01}, 3},
+		{{0x8C, 0x2B, 0x01}, 3},
+		{{0x8C, 0x2C, 0x01}, 3},
+		{{0x8C, 0x2D, 0x01}, 3},
+		{{0x8C, 0x2E, 0x01}, 3},
+		{{0x8C, 0x2F, 0x01}, 3},
+		{{0x8C, 0x30, 0x01}, 3},
+		{{0x8C, 0x31, 0x01}, 3},
+		{{0x8C, 0x32, 0x01}, 3},
+		{{0x8C, 0x33, 0x01}, 3},
+		{{0x8C, 0x34, 0x01}, 3},
+		{{0x8C, 0x35, 0x01}, 3},
+		{{0x8C, 0x36, 0x02}, 3},
+		{{0x8C, 0x37, 0x3a}, 3},
+		{{0x8C, 0x38, 0xa0}, 3},
+		{{0x8C, 0x39, 0xa6}, 3},
+		{{0x8C, 0x3A, 0x50}, 3},
+		{{0x8C, 0x3B, 0x00}, 3},
+		{{0x8C, 0x3C, 0x08}, 3},
+		{{0x8C, 0x3D, 0xa0}, 3},
+		{{0x8C, 0x3E, 0x64}, 3},
+		{{0x8C, 0x3F, 0x0a}, 3},
+		{{0x8C, 0x40, 0x31}, 3},
+		{{0x8C, 0x41, 0x00}, 3},
+		{{0x8C, 0x42, 0x44}, 3},
+		{{0x8C, 0x43, 0x7a}, 3},
+		{{0x8C, 0x44, 0x00}, 3},
+		{{0x8C, 0x45, 0x00}, 3},
+		{{0x8C, 0x46, 0x00}, 3},
+		{{0x8C, 0x47, 0x18}, 3},
+		{{0x8C, 0x48, 0x00}, 3},
+		{{0x8C, 0x49, 0x00}, 3},
+		{{0x8C, 0x4A, 0x00}, 3},
+		{{0x8C, 0x4B, 0xfe}, 3},
+		{{0x8C, 0x4C, 0x00}, 3},
+		{{0x8C, 0x4D, 0x57}, 3},
+		{{0x8C, 0x4E, 0x48}, 3},
+		{{0x8C, 0x4F, 0x59}, 3},
+		{{0x8C, 0x50, 0x20}, 3},
+		{{0x8C, 0x51, 0x54}, 3},
+		{{0x8C, 0x52, 0x48}, 3},
+		{{0x8C, 0x53, 0x49}, 3},
+		{{0x8C, 0x54, 0x53}, 3},
+		{{0x8C, 0x55, 0x20}, 3},
+		{{0x8C, 0x56, 0x53}, 3},
+		{{0x8C, 0x57, 0x48}, 3},
+		{{0x8C, 0x58, 0x49}, 3},
+		{{0x8C, 0x59, 0x54}, 3},
+		{{0x8C, 0x5A, 0x00}, 3},
+		{{0x8C, 0x5B, 0x00}, 3},
+		{{0x8C, 0x5C, 0x00}, 3},
+		{{0x8C, 0x5D, 0xfc}, 3},
+		{{0x8C, 0x5E, 0x00}, 3},
+		{{0x8C, 0x5F, 0x57}, 3},
+		{{0x8C, 0x60, 0x48}, 3},
+		{{0x8C, 0x61, 0x59}, 3},
+		{{0x8C, 0x62, 0x3f}, 3},
+		{{0x8C, 0x63, 0x0a}, 3},
+		{{0x8C, 0x64, 0x20}, 3},
+		{{0x8C, 0x65, 0x20}, 3},
+		{{0x8C, 0x66, 0x20}, 3},
+		{{0x8C, 0x67, 0x20}, 3},
+		{{0x8C, 0x68, 0x20}, 3},
+		{{0x8C, 0x69, 0x20}, 3},
+		{{0x8C, 0x6A, 0x20}, 3},
+		{{0x8C, 0x6B, 0x20}, 3},
+		{{0x8C, 0x6C, 0x00}, 3},
+		{{0x8C, 0x6D, 0x00}, 3},
+		{{0x8C, 0x6E, 0x00}, 3},
+		{{0x8C, 0x6F, 0xfd}, 3},
+		{{0x8C, 0x70, 0x00}, 3},
+		{{0x8C, 0x71, 0x17}, 3},
+		{{0x8C, 0x72, 0x46}, 3},
+		{{0x8C, 0x73, 0x0f}, 3},
+		{{0x8C, 0x74, 0xa0}, 3},
+		{{0x8C, 0x75, 0x1e}, 3},
+		{{0x8C, 0x76, 0x00}, 3},
+		{{0x8C, 0x77, 0x0a}, 3},
+		{{0x8C, 0x78, 0x20}, 3},
+		{{0x8C, 0x79, 0x20}, 3},
+		{{0x8C, 0x7A, 0x20}, 3},
+		{{0x8C, 0x7B, 0x20}, 3},
+		{{0x8C, 0x7C, 0x20}, 3},
+		{{0x8C, 0x7D, 0x20}, 3},
+		{{0x8C, 0x7E, 0x00}, 3},
+		{{0x8C, 0x7F, 0xe5}, 3},
+
+		{{0x85, 0xD1, 0x01}, 3},
+		{{0x85, 0x60, 0x24}, 3},
+		{{0x85, 0x63, 0x11}, 3},
+		{{0x85, 0x64, 0x0F}, 3},
+		{{0x8A, 0x02, 0x42}, 3},
+		{{0x85, 0x43, 0x02}, 3},            //DDC_CTL try to add DDC_ACTION when init finishes | 0x04
+		{{0x85, 0x44, 0x11}, 3},
+		{{0x86, 0x00, 0x00}, 3},
+		{{0x86, 0x02, 0xF3}, 3},
+		{{0x86, 0x03, 0x02}, 3},
+		{{0x86, 0x04, 0x0C}, 3},
+		{{0x86, 0x06, 0x05}, 3},
+		{{0x86, 0x07, 0x00}, 3},
+		{{0x86, 0x52, 0x02}, 3},
+		{{0x86, 0x71, 0xBA, 0x49, 0x0C, 0x02}, 6},
+		{{0x86, 0x75, 0x89, 0xB0, 0xE1, 0x01}, 6},
+		{{0x85, 0x4A, 0x01}, 3}             //INIT_END
+};
+
+struct tc358870_msg dsi_init_data[] = {
+	{{0x00, 0x04, 0x04, 0x00}, 4},
+	{{0x00, 0x02, 0x00, 0x12}, 4},
+
+	{{USLEEP_PAUSE}, 1000},
+
+	{{0x00, 0x02, 0x00, 0x00}, 4},
+	{{0x00, 0x06, 0x08, 0x00}, 4},
+	{{0x01, 0x08, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x0C, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0xA0, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0xAC, 0xD0, 0x94, 0x00, 0x00}, 6},      //MIPI_PLL_CONF 48 MHz Roman
+	//{{0x02, 0xAC, 0x8A, 0x90, 0x00, 0x00}, 6},    //MIPI_PLL_CONF 48 MHz default
+	//{{0x02, 0xAC, 0xA0, 0xD0, 0x00, 0x00}, 6},    //MIPI_PLL_CONF 50 MHz
+
+	{{USLEEP_PAUSE}, 1500},
+
+	{{0x02, 0xA0, 0x03, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x18, 0x14, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x20, 0x05, 0x12, 0x00, 0x00}, 6},
+	{{0x01, 0x24, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x28, 0x01, 0x01, 0x00, 0x00}, 6},
+	{{0x01, 0x30, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x01, 0x34, 0x00, 0x50, 0x00, 0x00}, 6},
+	{{0x01, 0x38, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x01, 0x3C, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x01, 0x40, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x01, 0x44, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x01, 0x48, 0x00, 0x10, 0x00, 0x00}, 6},
+	{{0x01, 0x4C, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x01, 0x50, 0x61, 0x01, 0x00, 0x00}, 6},
+	{{0x01, 0x54, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x58, 0xC8, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x68, 0x2A, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x70, 0x7C, 0x02, 0x00, 0x00}, 6},
+	{{0x01, 0x7C, 0x81, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x8C, 0x3A, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x90, 0x84, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0xA4, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0xC0, 0x15, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x14, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x1C, 0x80, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x24, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x54, 0x04, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x58, 0x04, 0x02, 0x1E, 0x00}, 6},
+	{{0x02, 0x5C, 0x08, 0x00, 0x0A, 0x00}, 6},
+	{{0x02, 0x60, 0x06, 0x00, 0x0E, 0x00}, 6},
+	{{0x02, 0x64, 0x15, 0x48, 0x00, 0x00}, 6},
+	{{0x02, 0x68, 0x0C, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x6C, 0x07, 0x00, 0x0A, 0x00}, 6},
+	{{0x02, 0x70, 0x20, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x74, 0x1F, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x78, 0x05, 0x00, 0x04, 0x00}, 6},
+	{{0x02, 0x7C, 0x02, 0x00, 0x00, 0x00}, 6},
+	{{0x02, 0x88, 0xAA, 0x02, 0x00, 0x00}, 6},
+	{{0x01, 0x1C, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x08, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x0C, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0xA0, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0xAC, 0xD0, 0x94, 0x00, 0x00}, 6},      //MIPI_PLL_CONF 48 MHz Roman
+	//{{0x04, 0xAC, 0x8A, 0x90, 0x00, 0x00}, 6},    //MIPI_PLL_CONF 48 MHz default
+	//{{0x04, 0xAC, 0xA0, 0xD0, 0x00, 0x00}, 6},    //MIPI_PLL_CONF 50 MHz
+
+	{{USLEEP_PAUSE}, 1500},
+
+	{{0x04, 0xA0, 0x03, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x18, 0x14, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x20, 0x05, 0x12, 0x00, 0x00}, 6},
+	{{0x03, 0x24, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x28, 0x01, 0x01, 0x00, 0x00}, 6},
+	{{0x03, 0x30, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x03, 0x34, 0x00, 0x50, 0x00, 0x00}, 6},
+	{{0x03, 0x38, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x03, 0x3C, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x03, 0x40, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x03, 0x44, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x03, 0x48, 0x00, 0x10, 0x00, 0x00}, 6},
+	{{0x03, 0x4C, 0x00, 0x00, 0x01, 0x00}, 6},
+	{{0x03, 0x50, 0x61, 0x01, 0x00, 0x00}, 6},
+	{{0x03, 0x54, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x58, 0xC8, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x68, 0x2A, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x70, 0x7C, 0x02, 0x00, 0x00}, 6},
+	{{0x03, 0x7C, 0x81, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x8C, 0x3A, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x90, 0x84, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0xA4, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0xC0, 0x15, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x14, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x1C, 0x80, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x24, 0x00, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x54, 0x04, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x58, 0x04, 0x02, 0x1E, 0x00}, 6},
+	{{0x04, 0x5C, 0x08, 0x00, 0x0A, 0x00}, 6},
+	{{0x04, 0x60, 0x06, 0x00, 0x0E, 0x00}, 6},
+	{{0x04, 0x64, 0x15, 0x48, 0x00, 0x00}, 6},
+	{{0x04, 0x68, 0x0C, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x6C, 0x07, 0x00, 0x0A, 0x00}, 6},
+	{{0x04, 0x70, 0x20, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x74, 0x1F, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x78, 0x05, 0x00, 0x04, 0x00}, 6},
+	{{0x04, 0x7C, 0x02, 0x00, 0x00, 0x00}, 6},
+	{{0x04, 0x88, 0xAA, 0x02, 0x00, 0x00}, 6},
+	{{0x03, 0x1C, 0x01, 0x00, 0x00, 0x00}, 6},
+	{{0x01, 0x10, 0x16, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x10, 0x16, 0x00, 0x00, 0x00}, 6},
+
+	{{USLEEP_PAUSE}, 1000},
+
+	{{0x05, 0x00, 0x04, 0x00}, 4},
+	{{0x05, 0x04, 0x05, 0x00}, 4},
+	{{0x05, 0x04, 0x11, 0x00}, 4},
+	{{0x05, 0x04, 0x05, 0x00}, 4},
+	{{0x05, 0x04, 0x00, 0x00}, 4},
+
+	{{USLEEP_PAUSE}, 300000},
+
+	{{0x05, 0x04, 0x23, 0x00}, 4},
+	{{0x05, 0x04, 0xB0, 0x04}, 4},
+	{{0x05, 0x04, 0x23, 0x00}, 4},
+	{{0x05, 0x04, 0xB3, 0x10}, 4},
+	{{0x05, 0x04, 0x23, 0x00}, 4},
+	{{0x05, 0x04, 0xB0, 0x03}, 4},
+	{{0x05, 0x04, 0x15, 0x00}, 4},
+	{{0x05, 0x04, 0x36, 0x00}, 4},
+	{{0x05, 0x04, 0x15, 0x00}, 4},
+	{{0x05, 0x04, 0x3A, 0x77}, 4},
+	{{0x05, 0x04, 0x05, 0x00}, 4},
+	{{0x05, 0x04, 0x29, 0x00}, 4},
+	{{0x05, 0x04, 0x05, 0x00}, 4},
+	{{0x05, 0x04, 0x00, 0x00}, 4},
+
+	{{USLEEP_PAUSE}, 30000},
+
+	{{0x50, 0x00, 0x00, 0x00}, 4},
+	{{0x50, 0x08, 0x70, 0x08}, 4},
+	{{0x50, 0x0C, 0x00, 0x80}, 4},
+	{{0x50, 0x80, 0x00, 0x00}, 4},
+	{{0x50, 0x88, 0x70, 0x08}, 4},
+	{{0x00, 0x04, 0x37, 0x0C}, 4},
+	{{0x00, 0x06, 0x00, 0x00}, 4},
+	{{0x01, 0x10, 0x06, 0x00, 0x00, 0x00}, 6},
+	{{0x03, 0x10, 0x06, 0x00, 0x00, 0x00}, 6}
+};
+
+static inline struct tc358870 *bridge_to_tc358870(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct tc358870, bridge);
+}
+
+static inline struct tc358870 *connector_to_tc358870(struct drm_connector *con)
+{
+	return container_of(con, struct tc358870, connector);
+}
+
+static int i2c_write(struct tc358870 *tc_data, char *buf, int len)
+{
+	int ret;
+	mutex_lock(&tc_data->lock);
+
+	ret = i2c_master_send(tc_data->client, buf, len);
+
+	if (ret < 0) {
+			dev_err(tc_data->device, "I2C write failed with error: %d\n", ret);
+			return ret;
+	}
+	mutex_unlock(&tc_data->lock);
+	return 0;
+}
+
+
+static int i2c_read(struct tc358870 *tc_data, char *cmd, char *buf, int len)
+{
+	int ret;
+	struct i2c_msg msg[2] = {
+	    {
+	        .addr = tc_data->client->addr,
+	        .len = 2,
+	        .buf = cmd,
+	    },
+	    {
+	        .addr = tc_data->client->addr,
+	        .flags = I2C_M_RD,
+	        .len = len,
+	        .buf = buf,
+	    }
+	};
+
+	mutex_lock(&tc_data->lock);
+	ret = i2c_transfer(tc_data->client->adapter, msg, 2);
+	mutex_unlock(&tc_data->lock);
+
+	if (ret < 0) {
+	    dev_err(tc_data->device, "I2C read failed with error: %d\n", ret);
+	    return ret;
+	}
+	return 0;
+}
+
+static int tc358870_reset(struct tc358870 *tc_data, int msec)
+{
+	gpiod_set_value(tc_data->tc358870_reset, 1);
+	msleep(msec);
+	gpiod_set_value(tc_data->tc358870_reset, 0);
+
+	if (IS_ERR(tc_data->tc358870_reset)) {
+		dev_err(tc_data->device, "Failed to reset\n");
+		return PTR_ERR(tc_data->tc358870_reset);
+	}
+
+	msleep(20);	// wait to stabilize
+	return 0;
+}
+
+static int tc358870_wait_for_reg_sys(struct tc358870 *tc_data, int expected_value)
+{
+	char readbuf = 0;
+	char readaddr[2] = {REG_SYS_STATUS};
+	int i;
+	int ret;
+
+	// wait max 5 s to receive expected value form REG_SYS_STATUS
+	for (i = 50; ((readbuf & expected_value) != expected_value) && (i > 0); i--)
+	{
+		readbuf = 0;
+		ret = i2c_read(tc_data, readaddr, &readbuf, 1);
+		dev_dbg(tc_data->device, "tc358870 REG_SYS_STATUS: 0x%02x\n", readbuf);
+		if((readbuf & expected_value) == expected_value) break;
+		if (ret < 0){
+			dev_err(tc_data->device, "read error: %d\n", ret);
+			return ret;
+
+		}
+		msleep(100);
+	}
+
+	if ((readbuf & expected_value) != expected_value)
+	{
+		dev_err(tc_data->device, "tc358870 REG_SYS_STATUS didn't return"
+			" expected value: %x\n", expected_value);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int tc358870_hdmi_init(struct tc358870 *tc_data)
+{
+	// init HDMI
+	int i;
+	int ret;
+
+	for(i = 0; i < (sizeof(tc358870_init_data) / sizeof(struct tc358870_msg)); i++)
+	{
+		ret = i2c_write(tc_data, tc358870_init_data[i].data, tc358870_init_data[i].len);
+		if (ret < 0) return ret;
+	}
+	return 0;
+}
+
+static int tc358870_dsi_init(struct tc358870 *tc_data)
+{
+	int ret;
+	int i;
+	ret = tc358870_wait_for_reg_sys(tc_data, SYS_STATUS_SYNC);
+	if (ret < 0) {
+		return ret;
+	}
+	usleep_range(20000, 21000);
+
+	// enable iovdd_lcd-supply
+	ret  = regulator_enable(tc_data->iovdd_lcd_supply);
+	if (ret < 0) {
+		dev_err(tc_data->device, "Regulator iovdd_lcd-supply error: %d\n", ret);
+		return -EIO;
+	}
+	usleep_range(20000,21000);
+
+	// enable avdd_lcd-supply
+	ret  = regulator_enable(tc_data->avdd_lcd_supply);
+	if (ret < 0) {
+		dev_err(tc_data->device, "Regulator avdd_lcd-supply error: %d\n", ret);
+		return -EIO;
+	}
+	msleep(100);
+
+	// unreset LCD controller
+	gpiod_set_value(tc_data->lcd_reset, 0);
+	usleep_range(20000, 21000);
+
+	// write DDC data
+	for(i = 0; i < (sizeof(dsi_init_data) / sizeof(struct tc358870_msg)); i++)
+	{
+		// there need to be some delays between writes
+		if(dsi_init_data[i].data[0] == USLEEP_PAUSE) {
+			usleep_range(dsi_init_data[i].len, dsi_init_data[i].len + 1000);
+			continue;
+		}
+		ret = i2c_write(tc_data, dsi_init_data[i].data, dsi_init_data[i].len);
+		if (ret < 0) return ret;
+	}
+	return 0;
+}
+
+static int tc358870_init(struct tc358870 *tc_data)
+{
+	int ret;
+	char readaddr[2] = {REG_CHIP_ID};
+	char version[2];
+	if (!tc_data->device->of_node) {
+		dev_err(tc_data->device, "not DT device\n");
+		return -ENODEV;
+	}
+
+	tc_data->vdd12_mipi_supply = devm_regulator_get(tc_data->device, "vdd12_mipi");
+	tc_data->vdd11_hdmi_supply = devm_regulator_get(tc_data->device, "vdd11_hdmi");
+	tc_data->avdd_lcd_supply = devm_regulator_get(tc_data->device, "avdd_lcd");
+	tc_data->iovdd_lcd_supply = devm_regulator_get(tc_data->device, "iovdd_lcd");
+	if (IS_ERR(tc_data->vdd12_mipi_supply) || IS_ERR(tc_data->vdd11_hdmi_supply) ||
+		IS_ERR(tc_data->avdd_lcd_supply) || IS_ERR(tc_data->iovdd_lcd_supply))
+	{
+		dev_err(tc_data->device, "regulator_bulk_get failed\n");
+		return -EPROBE_DEFER;
+	}
+
+	tc_data->tc358870_reset = devm_gpiod_get(tc_data->device, "tc358870-reset",
+		GPIOD_OUT_HIGH);
+	tc_data->lcd_reset = devm_gpiod_get(tc_data->device, "lcd-reset",
+		GPIOD_OUT_HIGH);
+
+	if (IS_ERR(tc_data->tc358870_reset) || IS_ERR(tc_data->lcd_reset))
+	{
+		dev_err(tc_data->device, "Failed to get gpios from DT\n");
+		return -EPROBE_DEFER;
+	}
+
+	// enable vdd12_mipi-supply and vdd11_hdmi-supply
+	ret  = regulator_enable(tc_data->vdd12_mipi_supply);
+	ret  = regulator_enable(tc_data->vdd11_hdmi_supply);
+	if(ret < 0)
+	{
+		dev_err(tc_data->device, "Regulator vdd12_mipi-supply or vdd11_hdmi-supply error: %d\n", ret);
+		return -EIO;
+	}
+	else dev_dbg(tc_data->device, "Regulator vdd12_mipi-supply and vdd11_hdmi-supply succesfully enabled\n");
+
+	msleep(20);
+
+	ret = tc358870_reset(tc_data, 10);
+	if (ret < 0) return ret;
+
+	// wait for HDMI DDC5V to come HIGH
+	ret = tc358870_wait_for_reg_sys(tc_data, SYS_STATUS_DDC5V);
+	if (ret < 0) {
+		dev_err(tc_data->device, "prode return\n");
+		return ret;
+	}
+
+	ret = i2c_read(tc_data, readaddr, version, 2);
+	if (ret < 0){
+		dev_err(tc_data->device, "I2C REG_CHIP_ID read error: %d\n", ret);
+		return ret;
+	}
+	dev_dbg(tc_data->device, "REG_CHIP_ID: 0x%02x%02x\n", version[0], version[1]);
+
+	return 0;
+}
+
+static int tc358870_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct tc358870 *tc_data;
+	struct device *device = &client->dev;
+	int ret;
+	int i;
+
+	tc_data = devm_kzalloc(device, sizeof(*tc_data), GFP_KERNEL);
+	if (!tc_data) return -ENOMEM;
+
+	tc_data->client = client;
+	tc_data->device = device;
+	mutex_init(&tc_data->lock);
+
+	dev_dbg(tc_data->device, "probing for TC358870XBG i2c\n");
+
+	ret = tc358870_init(tc_data);
+	if (ret)
+		goto fail;
+
+	ret = tc358870_hdmi_init(tc_data);
+	if (ret)
+		goto fail;
+
+	ret = tc358870_dsi_init(tc_data);
+	if (ret)
+		goto fail;
+
+	i2c_set_clientdata(client, tc_data);
+	ret = 0;
+fail:
+	mutex_unlock(&tc_data->lock);
+	return ret;
+}
+
+static int tc358870_remove(struct i2c_client *client)
+{
+	struct tc358870 *tc_data = i2c_get_clientdata(client);
+	return 0;
+}
+
+static const struct of_device_id tc358870_dt_match[] = {
+	{ .compatible = "toshiba,tc358870" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, tc358870_dt_match);
+
+static const struct i2c_device_id tc358870_id[] = {
+	{ "tc358870", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, tc358870_id);
+
+static struct i2c_driver tc358870_driver = {
+	.driver = {
+		.name	= "tc358870",
+		.of_match_table = tc358870_dt_match,
+	},
+	.probe = tc358870_probe,
+	.remove = tc358870_remove,
+	.id_table = tc358870_id,
+};
+
+module_i2c_driver(tc358870_driver);
+
+MODULE_DESCRIPTION("Toshiba TC358870XBG HDMI-DSI converter configuration driver");
+MODULE_AUTHOR("Prusa Research <info@prusa3d.cz>");
+MODULE_LICENSE("GPL");
-- 
2.24.0

