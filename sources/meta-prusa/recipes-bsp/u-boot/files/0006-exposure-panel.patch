From 941b3ea0b3f36e23bf71ab4452024c815f253676 Mon Sep 17 00:00:00 2001
From: Roman Beranek <roman.beranek@prusa3d.com>
Date: Thu, 17 Dec 2020 08:56:07 +0100
Subject: [PATCH 1/3] exposure panel identification

---
 arch/arm/mach-sunxi/Kconfig         |  10 +
 board/sunxi/Makefile                |   6 +
 board/sunxi/board.c                 |  37 ++
 board/sunxi/panel-detector-uclass.c |  26 ++
 board/sunxi/panel_detector.h        |  18 +
 board/sunxi/tc358870.c              | 565 ++++++++++++++++++++++++++++
 board/sunxi/tc358870.h              |  88 +++++
 include/dm/uclass-id.h              |   1 +
 8 files changed, 751 insertions(+)
 create mode 100644 board/sunxi/panel-detector-uclass.c
 create mode 100644 board/sunxi/panel_detector.h
 create mode 100644 board/sunxi/tc358870.c
 create mode 100644 board/sunxi/tc358870.h

diff --git a/arch/arm/mach-sunxi/Kconfig b/arch/arm/mach-sunxi/Kconfig
index bc8509b72a..2e601598c8 100644
--- a/arch/arm/mach-sunxi/Kconfig
+++ b/arch/arm/mach-sunxi/Kconfig
@@ -1088,6 +1088,16 @@ config BLUETOOTH_DT_DEVICE_FIXUP
 	  The used address is "bdaddr" if set, and "ethaddr" with the LSB
 	  flipped elsewise.
 
+config BRIDGED_PANEL_DETECTION
+	bool "Detect panel connected to a TC358870 bridge"
+	default n
+	depends on MACH_SUN50I
+	select DM_GPIO
+	select DM_I2C
+	select DM_REGULATOR
+	select DM_REGULATOR_FIXED
+	select SSCANF
+
 endif
 
 config CHIP_DIP_SCAN
diff --git a/board/sunxi/Makefile b/board/sunxi/Makefile
index aac421ff60..d0cf81d7ff 100644
--- a/board/sunxi/Makefile
+++ b/board/sunxi/Makefile
@@ -15,4 +15,10 @@ obj-$(CONFIG_CHIP_DIP_SCAN)	+= chip.o
 
 ifndef CONFIG_SPL_BUILD
 obj-$(CONFIG_EFI_PARTITION)	+= grow_sd.o
+
+ifdef CONFIG_BRIDGED_PANEL_DETECTION
+obj-y	+= panel-detector-uclass.o
+obj-y	+= tc358870.o
+endif
+
 endif
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 50167b625b..4767f4b1aa 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -47,6 +47,7 @@
 #include <spl.h>
 #include <sy8106a.h>
 #include <asm/setup.h>
+#include "panel_detector.h"
 
 #if defined CONFIG_VIDEO_LCD_PANEL_I2C && !(defined CONFIG_SPL_BUILD)
 /* So that we can use pin names in Kconfig and sunxi_name_to_gpio() */
@@ -989,6 +990,27 @@ int board_late_init(void)
 #ifdef CONFIG_USB_ETHER
 	usb_ether_init();
 #endif
+#ifdef CONFIG_BRIDGED_PANEL_DETECTION
+	int r;
+	struct udevice *detector;
+	char const *panel_name;
+	char *edid_arg;
+	size_t edid_arg_length;
+
+	r = uclass_first_device(UCLASS_PANEL_DETECTOR, &detector);
+	if (r)
+		return r;
+	panel_name = panel_detector_get_panel_name(detector);
+	if (strlen(panel_name)) {
+		edid_arg_length = 37 + strlen(panel_name);
+		edid_arg = kmalloc(edid_arg_length, GFP_KERNEL);
+		snprintf(edid_arg, edid_arg_length, "drm.edid_firmware=HDMI-A-1:edid/%s.bin", panel_name);
+		printf("panel_detector: found %s panel\n", panel_name);
+	} else {
+		edid_arg = "video=HDMI-A-1:d";
+	}
+	env_set("edid_bootarg", edid_arg);
+#endif
 
 	return 0;
 }
@@ -1041,6 +1063,21 @@ int ft_board_setup(void *blob, struct bd_info *bd)
 	r = sunxi_simplefb_setup(blob);
 	if (r)
 		return r;
+#endif
+#ifdef CONFIG_BRIDGED_PANEL_DETECTION
+	int offset;
+	struct udevice *detector;
+
+	r = uclass_first_device(UCLASS_PANEL_DETECTOR, &detector);
+	if (r)
+		return r;
+	offset = fdt_node_offset_by_compatible(blob, -1, "toshiba,tc358870");
+	if (offset < 0)
+		return offset;
+	r = fdt_setprop_string(blob, offset, "panel-name", panel_detector_get_panel_name(detector));
+	r = fdt_setprop_u64(blob, offset, "match-data", panel_detector_get_match_data(detector));
+	if (r)
+		return r;
 #endif
 	return 0;
 }
diff --git a/board/sunxi/panel-detector-uclass.c b/board/sunxi/panel-detector-uclass.c
new file mode 100644
index 0000000000..41eec54249
--- /dev/null
+++ b/board/sunxi/panel-detector-uclass.c
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Prusa Development, a.s.
+ * Written by Roman Beranek <roman.beranek@prusa3d.com>
+ */
+
+#include <dm.h>
+#include "panel_detector.h"
+
+const char* panel_detector_get_panel_name(struct udevice *dev)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	return uc_priv->panel_name;
+}
+
+u64 panel_detector_get_match_data(struct udevice *dev)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	return uc_priv->match_data;
+}
+
+UCLASS_DRIVER(panel_detector) = {
+	.id			= UCLASS_PANEL_DETECTOR,
+	.name			= "panel_detector",
+	.per_device_auto	= sizeof(struct panel_detector_priv),
+};
diff --git a/board/sunxi/panel_detector.h b/board/sunxi/panel_detector.h
new file mode 100644
index 0000000000..65294be844
--- /dev/null
+++ b/board/sunxi/panel_detector.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2020 Prusa Development, a.s.
+ * Written by Roman Beranek <roman.beranek@prusa3d.com>
+ */
+
+#ifndef __PANEL_DETECTOR
+#define __PANEL_DETECTOR
+
+struct panel_detector_priv {
+	char const* panel_name;
+	u64 match_data;
+};
+
+const char* panel_detector_get_panel_name(struct udevice *dev);
+u64 panel_detector_get_match_data(struct udevice *dev);
+
+#endif
diff --git a/board/sunxi/tc358870.c b/board/sunxi/tc358870.c
new file mode 100644
index 0000000000..1f30b21358
--- /dev/null
+++ b/board/sunxi/tc358870.c
@@ -0,0 +1,565 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2020 Prusa Development, a.s.
+ * Written by Roman Beranek <roman.beranek@prusa3d.com>
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <errno.h>
+#include <i2c.h>
+#include <log.h>
+#include <malloc.h>
+#include <mipi_display.h>
+#include <asm/byteorder.h>
+#include <asm/gpio.h>
+#include <linux/delay.h>
+#include <power/regulator.h>
+
+#include "panel_detector.h"
+#include "tc358870.h"
+
+static inline void freep(void *p) {
+	free(*(void**) p);
+}
+#define cleanup(x) __attribute__((__cleanup__(x)))
+#define cleanup_free cleanup(freep)
+
+struct tc358870_priv {
+	struct gpio_desc bridge_reset;
+	struct gpio_desc panel_reset;
+};
+
+enum i2c_xfer {
+	I2C_READ = 0,
+	I2C_WRITE = 1,
+};
+
+static void tc358870_print_xfer(enum i2c_xfer rw, u8 *reg, u8 *data, size_t len)
+{
+	static const char* const labels[] = {
+		[I2C_READ] = "I2C READ ",
+		[I2C_WRITE] = "I2C_WRITE",
+	};
+	int i;
+
+	log_debug("%s [0x%02x%02x]: 0x", labels[rw], reg[rw ? 0 : 1], reg[rw ? 1 : 0]);
+	for (i = (int)len - 1; i >= 0; i--)
+		log_debug("%02x", data[i]);
+	log_debug("\n");
+}
+
+static int tc358870_write(struct udevice *dev, u16 reg, const void* buf, size_t len)
+{
+	cleanup_free u8 *xfer = NULL;
+	struct i2c_msg msg;
+	int ret;
+	size_t size;
+	struct dm_i2c_chip *chip = dev_get_parent_plat(dev);
+
+	size = 2 + len;
+	xfer = malloc(size);
+	if (!xfer)
+		return -ENOMEM;
+
+	cpu_to_be16s(&reg);
+
+	msg.addr = chip->chip_addr;
+	msg.flags = 0;
+	memcpy(xfer, &reg, sizeof(reg));
+	memcpy(xfer + 2, buf, len);
+	msg.buf = xfer;
+	msg.len = size;
+
+	tc358870_print_xfer(I2C_WRITE, xfer, xfer + 2, len);
+	ret = dm_i2c_xfer(dev, &msg, 1);
+	if (xfer[0] == 0x01u || xfer[0] == 0x02u) {
+		xfer[0] += 0x02u;
+		tc358870_print_xfer(I2C_WRITE, xfer, xfer + 2, len);
+		ret = dm_i2c_xfer(dev, &msg, 1);
+	}
+
+	if (ret < 0) {
+		log_err("%s: write failed, reg=%#x, ret=%d\n", __func__, reg, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int tc358870_read(struct udevice *dev, u16 reg_addr, void *data, size_t len)
+{
+	struct i2c_msg msg[2];
+	int ret;
+	struct dm_i2c_chip *chip = dev_get_parent_plat(dev);
+
+	/* TODO WTF? Register address is somehow being sent backwards. I2C driver bug? (mvtwsi) */
+	cpu_to_le16s(&reg_addr);
+
+	msg[0].addr = chip->chip_addr;
+	msg[0].flags = 0;
+	msg[0].buf = (u8*)&reg_addr;
+	msg[0].len = sizeof(reg_addr);
+	msg[1].addr = chip->chip_addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = data;
+	msg[1].len = len;
+	ret = dm_i2c_xfer(dev, msg, 2);
+
+	if (ret < 0) {
+		log_err("%s: read failed, reg=%.2x, ret=%d\n", __func__, (int)reg_addr, ret);
+		return ret;
+	}
+	tc358870_print_xfer(I2C_READ, msg[0].buf, msg[1].buf, len);
+
+	return 0;
+}
+
+static int tc358870_write_u16(struct udevice *dev, u16 reg_addr, u16 value)
+{
+	cpu_to_le16s(&value);
+	return tc358870_write(dev, reg_addr, &value, sizeof(value));
+}
+
+static int tc358870_write_u32(struct udevice *dev, u16 reg_addr, u32 value)
+{
+	cpu_to_le32s(&value);
+	return tc358870_write(dev, reg_addr, &value, sizeof(value));
+}
+
+#if 0
+static int tc358870_read_u16(struct udevice *dev, u16 reg_addr, u16 *value)
+{
+	int ret = tc358870_read(dev, reg_addr, value, sizeof(*value));
+	if (ret < 0) {
+		return ret;
+	}
+	le16_to_cpus(value);
+	return 0;
+}
+#endif
+
+static int tc358870_read_u32(struct udevice *dev, u16 reg_addr, u32 *value)
+{
+	int ret;
+	ret = tc358870_read(dev, reg_addr, value, sizeof(*value));
+	if (ret < 0) {
+		return ret;
+	}
+	le32_to_cpus(value);
+	return 0;
+}
+
+#if 0 /* TODO: Why does RX_STATE_INT_STAT stay 0? */
+static int tc358870_wait_for_lprx_done(struct udevice *dev, u8 iface)
+{
+#define LPRX_PKT_START		(1u << 3u)
+#define LPRX_PKT_DONE		(1u << 2u)
+#define LPRX_PKT_THRESH_HIT	(1u << 1u)
+	int i, ret = 0;
+	u32 mask = LPRX_PKT_START | LPRX_PKT_DONE | LPRX_PKT_THRESH_HIT;
+	u32 out = 0;
+	for (i = 50; ((out & LPRX_PKT_DONE) == 0) && (i > 0) && (ret >= 0); i--)
+	{
+		ret = tc358870_read_u32(dev, RX_STATE_INT_STAT + iface * 0x0200u, &out);
+		mdelay(5);
+	}
+	if (ret < 0) {
+		log_err("%s: read error %d\n", __func__, ret);
+		return ret;
+	}
+	if ((out & mask) == 0) {
+		log_err("%s: waiting for LPRX packet reception timed out\n", __func__);
+		return 0;
+	}
+	if (!(out & LPRX_PKT_DONE)) {
+		log_err("%s: not DONE yet!\n", __func__);
+	}
+	/* clear out the interrupt register */
+	tc358870_write_u32(dev, RX_STATE_INT_STAT + iface * 0x0200u, mask);
+	return 0;
+}
+#endif
+
+static ssize_t tc358770_fetch_from_fifo(struct udevice *dev, u8 iface, u8* data, int word_count)
+{
+	int i, len;
+	u32 fifo_level = 0;
+	u8 buf[4];
+
+	for (i = 50; i >= 0 && ((fifo_level + 1) * 4) < word_count; i--) {
+		tc358870_read_u32(dev, LPRX_FIFO_LEVEL + iface * 0x0200u, &fifo_level);
+		mdelay(10);
+	}
+	for (i = 0; fifo_level > 0; fifo_level--) {
+		if (i >= word_count) {
+			log_err("%s: unexpected data in RXFIFO\n", __func__);
+			return -EINVAL;
+		}
+		tc358870_read(dev, RXFIFO + iface * 0x0200u, data + i, 4);
+		i += 4;
+	}
+	if (i < word_count) {
+		len = word_count - i;
+		log_debug("%s: reading last %d bytes from FIFO\n", __func__, len);
+		if (len >= 4) log_err("%s: expected more data in FIFO\n", __func__);
+		tc358870_read(dev, RXFIFO + iface * 0x0200u, buf, 4);
+		memcpy(data + i, buf, len);
+		i += len;
+	}
+	return i;
+}
+
+static ssize_t tc358870_fetch_rx(struct udevice *dev, u8 iface, u8** buf)
+{
+	struct {
+		union {
+			u16 wc;
+			u8 data[2];
+		} rxwc;
+		u8 rxdt:6;
+		u8 rxvc:2;
+		u8 reserved;
+	} __attribute__((packed)) rxhdr;
+
+	u16 word_count;
+	int ret;
+
+	tc358870_read(dev, RX_HEADER + iface * 0x0200u, &rxhdr, sizeof(rxhdr));
+	switch (rxhdr.rxdt) {
+	case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:
+	case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:
+		word_count = 1;
+		break;
+	case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:
+	case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:
+		word_count = 2;
+		break;
+	case MIPI_DSI_RX_DCS_LONG_READ_RESPONSE:
+	case MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:
+		word_count = rxhdr.rxwc.wc;
+		break;
+	default:
+		word_count = 0;
+		break;
+	}
+
+	if (!word_count) return 0;
+
+	*buf = malloc(word_count);
+	if (!*buf)
+		return -ENOMEM;
+
+	switch (rxhdr.rxdt) {
+	case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE:
+	case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE:
+	case MIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE:
+	case MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE:
+		memcpy(*buf, rxhdr.rxwc.data, word_count);
+		break;
+	case MIPI_DSI_RX_DCS_LONG_READ_RESPONSE:
+	case MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:
+		ret = tc358770_fetch_from_fifo(dev, iface, *buf, word_count);
+		if (ret != word_count)
+			log_err("%s: mismatch: number of bytes fetched from FIFO(%d) != WC(%d)\n",
+				__func__, ret, word_count);
+		break;
+	default:
+		break;
+	}
+
+	return word_count;
+}
+
+static inline u16 packet_header(u8 type)
+{
+	switch (type) {
+	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
+	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
+	case MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:
+	case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+	case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+	case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+	case MIPI_DSI_DCS_READ:
+	case MIPI_DSI_DCS_SHORT_WRITE:
+	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+		return type;
+	case MIPI_DSI_GENERIC_LONG_WRITE:
+	case MIPI_DSI_DCS_LONG_WRITE:
+		return 0x8000u | type;
+	default:
+		return 0;
+	}
+}
+
+static ssize_t tc358870_dsi_read(struct udevice *dev, u8 iface, u8 type, u8 address, u8 **out)
+{
+	int ret;
+	if (iface > 1) return -EINVAL;
+	ret = tc358870_write_u16(dev, CMD_SEL, iface << 1u);
+	if (ret) return ret;
+	ret = tc358870_write_u16(dev, DCSCMD_Q, packet_header(type));
+	if (ret < 0) return ret;
+	ret = tc358870_write_u16(dev, DCSCMD_Q, address);
+	if (ret < 0) return ret;
+	mdelay(1);
+	return tc358870_fetch_rx(dev, iface, out);
+}
+
+static ssize_t tc358870_dsi_dcs_read(struct udevice *dev, u8 iface, u8 address, u8 **out)
+{
+	return tc358870_dsi_read(dev, iface, MIPI_DSI_DCS_READ, address, out);
+}
+
+static ssize_t tc358870_dsi_generic_read_short(struct udevice *dev, u8 iface, u8 address, u8 **out)
+{
+	return tc358870_dsi_read(dev, iface, MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM, address, out);
+}
+
+static int tc358870_dsi_generic_write_short(struct udevice *dev, u8 iface, u8 address, u8 param)
+{
+	int ret;
+	if (iface > 1) return -EINVAL;
+	ret = tc358870_write_u16(dev, CMD_SEL, iface);
+	if (ret) return ret;
+	ret = tc358870_write_u16(dev, DCSCMD_Q,
+				 packet_header(MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM));
+	if (ret) return ret;
+	ret = tc358870_write_u16(dev, DCSCMD_Q, address | (param << 8u));
+	return ret;
+}
+
+static void tc358870_dsi_init(struct udevice *dev)
+{
+	tc358870_write_u16(dev, ConfCtl0,		0x0004u);
+	tc358870_write_u16(dev, SysCtl,			0x1200u);
+	udelay(1000);
+	tc358870_write_u16(dev, SysCtl,			0x0000u);
+	tc358870_write_u16(dev, ConfCtl1,		0x0008u);
+
+	tc358870_write_u32(dev, DSITX_CLKEN,		0x00000001u);
+	tc358870_write_u32(dev, PPI_CLKSEL,		0x00000001u);
+	tc358870_write_u32(dev, MIPI_PLL_CTRL,		0x00000001u);
+	tc358870_write_u32(dev, MIPI_PLL_CONF,		0x00006d90u);
+	udelay(1500);
+	tc358870_write_u32(dev, MIPI_PLL_CTRL,		0x00000003u);
+	tc358870_write_u32(dev, LANE_ENABLE,		0x00000014u);
+	tc358870_write_u32(dev, LINE_INIT_COUNT,	0x00000e34u);
+	tc358870_write_u32(dev, HSTX_TO_COUNT,		0x00000000u);
+	tc358870_write_u32(dev, FUNC_ENABLE,		0x00000101u);
+	tc358870_write_u32(dev, DSI_TATO_COUNT,		0x00010000u);
+	tc358870_write_u32(dev, DSI_PRESP_BTA_COUNT,	0x00005000u);
+	tc358870_write_u32(dev, DSI_PRESP_LPR_COUNT,	0x00010000u);
+	tc358870_write_u32(dev, DSI_PRESP_LPW_COUNT,	0x00010000u);
+	tc358870_write_u32(dev, DSI_PRESP_HSR_COUNT,	0x00010000u);
+	tc358870_write_u32(dev, DSI_PRESP_HSW_COUNT,	0x00010000u);
+	tc358870_write_u32(dev, DSI_PR_TO_COUNT,	0x00001000u);
+	tc358870_write_u32(dev, DSI_LRX_H_TO_COUNT,	0x00010000u);
+	tc358870_write_u32(dev, FUNC_MODE,		0x00000160u);
+	tc358870_write_u32(dev, DSIRX_VC_ENABLE,	0x00000001u);
+	tc358870_write_u32(dev, IND_TO_COUNT,		0x000000c8u);
+	tc358870_write_u32(dev, DSI_HSYNC_STOP_COUNT,	0x0000002au);
+	tc358870_write_u32(dev, DSITX_MODE,		0x00000081u);
+	tc358870_write_u32(dev, APF_VDELAYCNT,		0x000001e8u);
+	tc358870_write_u32(dev, DSI_HSYNC_WIDTH,	0x00000021u);
+	tc358870_write_u32(dev, DSI_HBPR,		0x00000091u);
+	tc358870_write_u32(dev, DSI_RX_STATE_INT_MASK,	0x00000000u);
+	tc358870_write_u32(dev, DSI_LPRX_THRESH_COUNT,	0x00000015u);
+	tc358870_write_u32(dev, APP_SIDE_ERR_INT_MASK,	0x00000000u);
+	tc358870_write_u32(dev, DSI_RX_ERR_INT_MASK,	0x00000080u);
+	tc358870_write_u32(dev, PPI_DPHY_LPTXTIMECNT,	0x00000003u);
+	tc358870_write_u32(dev, PPI_DPHY_TCLK_HEADERCNT,0x00180203u);
+	tc358870_write_u32(dev, PPI_DPHY_TCLK_TRAILCNT,	0x00080007u);
+	tc358870_write_u32(dev, PPI_DPHY_THS_HEADERCNT,	0x000c0005u);
+	tc358870_write_u32(dev, PPI_DPHY_TWAKEUPCNT,	0x00004709u);
+	tc358870_write_u32(dev, PPI_DPHY_TCLK_POSTCNT,	0x0000000bu);
+	tc358870_write_u32(dev, PPI_DPHY_THSTRAILCNT,	0x00080006u);
+	tc358870_write_u32(dev, PPI_DPHY_HSTXVREGCNT,	0x00000020u);
+	tc358870_write_u32(dev, PPI_DPHY_HSTXVREGEN,	0x0000001fu);
+	tc358870_write_u32(dev, PPI_DSI_BTA_COUNT,	0x00030003u);
+	tc358870_write_u32(dev, PPI_DPHYTX_ADJUST,	0x00000002u);
+	tc358870_write_u32(dev, PPI_DPHY_CAP,		0x000002aau);
+	tc358870_write_u32(dev, DSITX_START,		0x00000001u);
+	tc358870_write_u32(dev, MODE_CONFIG,		0x00000016u);
+	udelay(1000);
+}
+
+static int tc358870_save_match_data(struct udevice *dev, const u8* data, size_t len)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	memcpy(&uc_priv->match_data, data, min(len, 8ul));
+	return 0;
+}
+
+static bool tc358870_match_ls055r1sx04(struct udevice *dev)
+{
+	static const u8 ALMID[] = { 0x01, 0x22, 0x34, 0x19 };
+	cleanup_free u8 *out = NULL;
+	ssize_t len;
+
+	tc358870_dsi_generic_write_short(dev, 0, 0xb0u, 0x00u);
+
+	len = tc358870_dsi_generic_read_short(dev, 0, 0xbfu, &out);
+	if (len <= 0 || !out) {
+		log_warning("%s: DSI read from BFh address failed (%ld)\n", __func__, len);
+		return false;
+	}
+	tc358870_save_match_data(dev, out, len);
+	if (len >= sizeof(ALMID) && memcmp(out, ALMID, sizeof(ALMID)) == 0) {
+		log_info("%s: matched ALMID: SHARP LS055R1SX04\n", __func__);
+		return true;
+	}
+	log_err("%s: ALMID doesn't match an R63419 driver.\n", __func__);
+	if (len == 0x1f) {
+		log_warning("%s: response length is correct though: PASS\n", __func__);
+		return true;
+	}
+	return false;
+}
+
+static bool tc358870_match_rv059fbb(struct udevice *dev)
+{
+	static const u8 ID[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66 };
+	cleanup_free u8 *out = NULL;
+	ssize_t len;
+
+	len = tc358870_dsi_dcs_read(dev, 1, 0xa1u, &out);
+
+	if (len <= 0 || !out) {
+		log_warning("%s: DSI read from A1h address failed\n", __func__);
+		return false;
+	}
+	tc358870_save_match_data(dev, out, len);
+	if (len >= sizeof(ID) && memcmp(out, ID, sizeof(ID)) == 0) {
+		log_info("%s: matched RV059FBB by descriptor block (112233445566)\n", __func__);
+		return true;
+	}
+	if (out[6] == 0xffu) {
+		log_info("%s: matched RV059FBB by Exit Code (0xff) at the end of A1h response\n", __func__);
+		return true;
+	}
+	if (len == 7) {
+		log_info("%s: matched RV059FBB by the length (7) of its response to A1h\n", __func__);
+		return true;
+	}
+
+	return false;
+}
+
+static int tc358870_panel_init(struct udevice *dev)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+
+	if (tc358870_match_ls055r1sx04(dev)) {
+		uc_priv->panel_name = "ls055r1sx04";
+	} else if (tc358870_match_rv059fbb(dev)) {
+		uc_priv->panel_name = "rv059fbb";
+	} else {
+		log_err("Couldn't identify any panel connected to the bridge.\n");
+	}
+
+	return 0;
+}
+
+static int tc358870_check_chipid(struct udevice *dev)
+{
+	struct __attribute__((packed)) {
+		u8 revid;
+		u8 chipid;
+	} chipid;
+	int ret;
+
+	ret = tc358870_read(dev, ChipID, &chipid, sizeof(chipid));
+	if (ret < 0) {
+		log_err("%s: read id failed: %d\n", __func__, ret);
+		return ret;
+	}
+	if (chipid.chipid != 0x47u) {
+		log_err("Chip ID mismatch! Expected 0x47 but received 0x%02x\n", chipid.chipid);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int tc358870_enable(struct udevice *dev)
+{
+	int ret;
+	struct tc358870_priv *priv = dev_get_priv(dev);
+
+	/* Reset */
+	dm_gpio_set_value(&priv->bridge_reset, true);
+	udelay(10);
+	dm_gpio_set_value(&priv->bridge_reset, false);
+	mdelay(100);
+
+	dm_gpio_set_value(&priv->panel_reset, true);
+	udelay(10);
+	dm_gpio_set_value(&priv->panel_reset, false);
+	mdelay(200);
+
+	ret = tc358870_check_chipid(dev);
+	if (ret) return -EINVAL;
+
+	tc358870_dsi_init(dev);
+	ret = tc358870_panel_init(dev);
+	if (ret < 0) return ret;
+
+	return 0;
+}
+
+static int tc358870_probe(struct udevice *dev)
+{
+	int ret;
+	struct udevice *reg;
+
+	struct tc358870_priv *priv = dev_get_priv(dev);
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+
+	if (device_get_uclass_id(dev->parent) != UCLASS_I2C)
+		return -EPROTONOSUPPORT;
+
+	ret = gpio_request_by_name(dev, "bridge-reset-gpios", 0, &priv->bridge_reset,
+				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	if (ret) {
+		log_err("%s: Could not decode bridge-reset-gpios (%d)\n", __func__, ret);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	ret = gpio_request_by_name(dev, "panel-reset-gpios", 0, &priv->panel_reset,
+				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
+	if (ret) {
+		log_err("%s: Could not decode panel-reset-gpios (%d)\n", __func__, ret);
+		if (ret != -ENOENT)
+			return ret;
+	}
+
+	ret = uclass_get_device_by_phandle(UCLASS_REGULATOR, dev,
+					   "avdd_lcd-supply", &reg);
+	if (!ret) {
+		ret = regulator_set_enable(reg, true);
+		if (ret < 0) {
+			log_err("%s: Failed to enable power: ret=%d\n", __func__, ret);
+			return ret;
+		}
+	} else if (ret != -ENOENT) {
+		log_err("%s: Failed to enable power: ret=%d\n", __func__, ret);
+		return ret;
+	}
+
+	uc_priv->panel_name = "";
+	return tc358870_enable(dev);
+}
+
+static const struct udevice_id tc358870_ids[] = {
+	{ .compatible = "toshiba,tc358870", },
+	{ }
+};
+
+U_BOOT_DRIVER(toshiba_tc358870) = {
+	.name	= "toshiba_tc358870",
+	.id	= UCLASS_PANEL_DETECTOR,
+	.of_match = tc358870_ids,
+	.probe	= tc358870_probe,
+	.priv_auto = sizeof(struct tc358870_priv),
+};
diff --git a/board/sunxi/tc358870.h b/board/sunxi/tc358870.h
new file mode 100644
index 0000000000..2ea0e1e643
--- /dev/null
+++ b/board/sunxi/tc358870.h
@@ -0,0 +1,88 @@
+#ifndef TC358870_H
+#define TC358870_H
+
+enum {
+	/* Global Control */
+	ChipID			= 0x0000u,
+	SysCtl			= 0x0002u,
+	ConfCtl0		= 0x0004u,
+	ConfCtl1		= 0x0006u,
+	/* DSI-TX0 TX Control */
+	DSITX_CLKEN		= 0x0108u,
+	PPI_CLKSEL		= 0x010cu,
+	MODE_CONFIG		= 0x0110u,
+	LANE_ENABLE		= 0x0118u,
+	DSITX_START		= 0x011cu,
+	LINE_INIT_COUNT		= 0x0120u,
+	HSTX_TO_COUNT		= 0x0124u,
+	FUNC_ENABLE		= 0x0128u,
+	DSI_TATO_COUNT		= 0x0130u,
+	DSI_PRESP_BTA_COUNT	= 0x0134u,
+	DSI_PRESP_LPR_COUNT	= 0x0138u,
+	DSI_PRESP_LPW_COUNT	= 0x013cu,
+	DSI_PRESP_HSR_COUNT	= 0x0140u,
+	DSI_PRESP_HSW_COUNT	= 0x0144u,
+	DSI_PR_TO_COUNT		= 0x0148u,
+	DSI_LRX_H_TO_COUNT	= 0x014cu,
+	FUNC_MODE		= 0x0150u,
+	DSIRX_VC_ENABLE		= 0x0154u,
+	IND_TO_COUNT		= 0x0158u,
+	INIT_INT_STAT		= 0x0160u,
+	DSI_HSYNC_STOP_COUNT	= 0x0168u,
+	/* DSI-TX0 APF Configuration */
+	APF_VDELAYCNT		= 0x0170u,
+	DSITX_MODE		= 0x017cu,
+	DSI_HSYNC_WIDTH		= 0x018cu,
+	DSI_HBPR		= 0x0190u,
+	/* DSI-TX0 RX Event */
+	RX_STATE_INT_STAT	= 0x01a0u,
+	DSI_RX_STATE_INT_MASK	= 0x01a4u,
+	TX_INTERNAL_STAT	= 0x01b0u,
+	ACKERROR		= 0x01b4u,
+	RXFIFO			= 0x01b8u,
+	RX_HEADER		= 0x01bcu,
+	LPRX_FIFO_LEVEL		= 0x01c4u,
+	DSI_LPRX_THRESH_COUNT	= 0x01c0u,
+	DSI_PRTO_INT_STAT	= 0x0208u,
+	APP_SIDE_ERR_INT_STAT	= 0x0210u,
+	APP_SIDE_ERR_INT_MASK	= 0x0214u,
+	DSI_RX_ERR_INT_STAT	= 0x0218u,
+	DSI_RX_ERR_INT_MASK	= 0x021cu,
+	/* DSI-TX0 LPTX */
+	DSI_LPTX_INT_MASK	= 0x0224u,
+	PPI_DPHY_LPRXCALCNTRL	= 0x0248u,
+	PPI_DPHY_LPRXAUTOCALST	= 0x024cu,
+	/* DSI-TX0 D-PHY Control */
+	PPI_DPHY_LPTXTIMECNT	= 0x0254u,
+	PPI_DPHY_TCLK_HEADERCNT	= 0x0258u,
+	PPI_DPHY_TCLK_TRAILCNT	= 0x025cu,
+	PPI_DPHY_THS_HEADERCNT	= 0x0260u,
+	PPI_DPHY_TWAKEUPCNT	= 0x0264u,
+	PPI_DPHY_TCLK_POSTCNT	= 0x0268u,
+	PPI_DPHY_THSTRAILCNT	= 0x026cu,
+	PPI_DPHY_HSTXVREGCNT	= 0x0270u,
+	PPI_DPHY_HSTXVREGEN	= 0x0274u,
+	PPI_DSI_BTA_COUNT	= 0x0278u,
+	PPI_DPHYTX_ADJUST	= 0x027cu,
+	PPI_DPHY_CAP		= 0x0288u,
+	/* DSI-TX0 MIPI PLL Control */
+	MIPI_PLL_CTRL		= 0x02a0u,
+	MIPI_PLL_CONF		= 0x02acu,
+	/* CDSI-TX Wrapper */
+	CMD_SEL			= 0x0500u,
+	DCSCMD_ST		= 0x0502u,
+	DCSCMD_Q		= 0x0504u,
+
+	/* HDMI RX Audio Control */
+	PHY_CTL			= 0x8410u,
+	PHY_ENB			= 0x8413u,
+	APLL_CTL		= 0x84f0u,
+	DDCIO_CTL		= 0x84f4u,
+	SYS_STATUS		= 0x8520u,
+	SYS_FREQ0		= 0x8540u,
+	SYS_FREQ1		= 0x8541u,
+	DDC_CTL			= 0x8543u,
+	HPD_CTL			= 0x8544u,
+};
+
+#endif
diff --git a/include/dm/uclass-id.h b/include/dm/uclass-id.h
index d800f679d5..455a726c47 100644
--- a/include/dm/uclass-id.h
+++ b/include/dm/uclass-id.h
@@ -79,6 +79,7 @@ enum uclass_id {
 	UCLASS_P2SB,		/* (x86) Primary-to-Sideband Bus */
 	UCLASS_PANEL,		/* Display panel, such as an LCD */
 	UCLASS_PANEL_BACKLIGHT,	/* Backlight controller for panel */
+	UCLASS_PANEL_DETECTOR,
 	UCLASS_PCH,		/* x86 platform controller hub */
 	UCLASS_PCI,		/* PCI bus */
 	UCLASS_PCI_EP,		/* PCI endpoint device */
-- 
2.34.0


From c18b4b8bab5b865f26c55c32341ac986708d4ed9 Mon Sep 17 00:00:00 2001
From: Roman Beranek <roman.beranek@prusa3d.com>
Date: Thu, 4 Feb 2021 13:36:25 +0100
Subject: [PATCH 2/3] tc358870: switch VC if requested panel IC

---
 board/sunxi/tc358870.c | 85 ++++++++++++++++++++++++++++++++++-----
 1 file changed, 70 insertions(+), 9 deletions(-)

diff --git a/board/sunxi/tc358870.c b/board/sunxi/tc358870.c
index 1f30b21358..191895df50 100644
--- a/board/sunxi/tc358870.c
+++ b/board/sunxi/tc358870.c
@@ -28,6 +28,7 @@ static inline void freep(void *p) {
 struct tc358870_priv {
 	struct gpio_desc bridge_reset;
 	struct gpio_desc panel_reset;
+	u8 vc;
 };
 
 enum i2c_xfer {
@@ -221,9 +222,9 @@ static ssize_t tc358870_fetch_rx(struct udevice *dev, u8 iface, u8** buf)
 		u8 rxvc:2;
 		u8 reserved;
 	} __attribute__((packed)) rxhdr;
-
 	u16 word_count;
 	int ret;
+	struct tc358870_priv *priv = dev_get_priv(dev);
 
 	tc358870_read(dev, RX_HEADER + iface * 0x0200u, &rxhdr, sizeof(rxhdr));
 	switch (rxhdr.rxdt) {
@@ -239,6 +240,13 @@ static ssize_t tc358870_fetch_rx(struct udevice *dev, u8 iface, u8** buf)
 	case MIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE:
 		word_count = rxhdr.rxwc.wc;
 		break;
+	case MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT:
+		log_warning("Received ACK & Error Report 0x%04x, VC=%d\n", rxhdr.rxwc.wc, rxhdr.rxvc);
+		if (!(rxhdr.rxwc.wc & BIT(12))) return -EFAULT;
+		log_warning("Updating VC to %d.\n", rxhdr.rxvc);
+		if (priv->vc == rxhdr.rxvc) return -EBADMSG;
+		priv->vc = rxhdr.rxvc;
+		return -EAGAIN;
 	default:
 		word_count = 0;
 		break;
@@ -271,8 +279,10 @@ static ssize_t tc358870_fetch_rx(struct udevice *dev, u8 iface, u8** buf)
 	return word_count;
 }
 
-static inline u16 packet_header(u8 type)
+static inline u16 packet_header(struct udevice *dev, u8 type)
 {
+	struct tc358870_priv *priv = dev_get_priv(dev);
+	u8 vc = ((priv->vc & 0x3) << 6);
 	switch (type) {
 	case MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:
 	case MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:
@@ -283,10 +293,10 @@ static inline u16 packet_header(u8 type)
 	case MIPI_DSI_DCS_READ:
 	case MIPI_DSI_DCS_SHORT_WRITE:
 	case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
-		return type;
+		return type | vc;
 	case MIPI_DSI_GENERIC_LONG_WRITE:
 	case MIPI_DSI_DCS_LONG_WRITE:
-		return 0x8000u | type;
+		return 0x8000u | type | vc;
 	default:
 		return 0;
 	}
@@ -298,12 +308,16 @@ static ssize_t tc358870_dsi_read(struct udevice *dev, u8 iface, u8 type, u8 addr
 	if (iface > 1) return -EINVAL;
 	ret = tc358870_write_u16(dev, CMD_SEL, iface << 1u);
 	if (ret) return ret;
-	ret = tc358870_write_u16(dev, DCSCMD_Q, packet_header(type));
+	ret = tc358870_write_u16(dev, DCSCMD_Q, packet_header(dev, type));
 	if (ret < 0) return ret;
 	ret = tc358870_write_u16(dev, DCSCMD_Q, address);
 	if (ret < 0) return ret;
 	mdelay(1);
-	return tc358870_fetch_rx(dev, iface, out);
+	ret = tc358870_fetch_rx(dev, iface, out);
+	if (ret == -EAGAIN) {
+		return tc358870_dsi_read(dev, iface, type, address, out);
+	}
+	return ret;
 }
 
 static ssize_t tc358870_dsi_dcs_read(struct udevice *dev, u8 iface, u8 address, u8 **out)
@@ -316,19 +330,61 @@ static ssize_t tc358870_dsi_generic_read_short(struct udevice *dev, u8 iface, u8
 	return tc358870_dsi_read(dev, iface, MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM, address, out);
 }
 
+static int tc358870_dsi_dcs_write(struct udevice *dev, u8 iface, u8 cmd)
+{
+	int ret;
+	if (iface > 1) return -EINVAL;
+	ret = tc358870_write_u16(dev, CMD_SEL, iface << 1u);
+	if (ret) return ret;
+	ret = tc358870_write_u16(dev, DCSCMD_Q, packet_header(dev, MIPI_DSI_DCS_SHORT_WRITE));
+	if (ret) return ret;
+	ret = tc358870_write_u16(dev, DCSCMD_Q, cmd);
+	return ret;
+}
+
 static int tc358870_dsi_generic_write_short(struct udevice *dev, u8 iface, u8 address, u8 param)
 {
 	int ret;
 	if (iface > 1) return -EINVAL;
-	ret = tc358870_write_u16(dev, CMD_SEL, iface);
+	ret = tc358870_write_u16(dev, CMD_SEL, iface << 1u);
 	if (ret) return ret;
 	ret = tc358870_write_u16(dev, DCSCMD_Q,
-				 packet_header(MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM));
+				 packet_header(dev, MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM));
 	if (ret) return ret;
 	ret = tc358870_write_u16(dev, DCSCMD_Q, address | (param << 8u));
 	return ret;
 }
 
+static int tc358870_dsi_write_long(struct udevice *dev, u8 type, u8 cmd, u8 const* data, ssize_t len)
+{
+	u16 buf;
+	int i, ret;
+
+	ret = tc358870_write_u16(dev, DCSCMD_Q, packet_header(dev, type));
+	if (ret < 0) return ret;
+	ret = tc358870_write_u16(dev, DCSCMD_Q, (u16)len + 1);
+	if (ret < 0) return ret;
+	for (i = -1; i < len; i += 2) {
+		buf = (i == -1) ? cmd : data[i];
+		if ((len - (i + 2)) >= 0) {
+			buf |= (u16)(data[i + 1] << 8u);
+		}
+		ret = tc358870_write_u16(dev, DCSCMD_Q, buf);
+		if (ret < 0) return ret;
+	}
+	return 0;
+}
+
+static int tc358870_dsi_generic_write_long(struct udevice *dev, u8 iface, u8 cmd, u8 const* data, ssize_t len)
+{
+	int ret;
+	if (iface > 1) return -EINVAL;
+	ret = tc358870_write_u16(dev, CMD_SEL, iface << 1u);
+	if (ret) return ret;
+
+	return tc358870_dsi_write_long(dev, MIPI_DSI_GENERIC_LONG_WRITE, cmd, data, len);
+}
+
 static void tc358870_dsi_init(struct udevice *dev)
 {
 	tc358870_write_u16(dev, ConfCtl0,		0x0004u);
@@ -356,7 +412,7 @@ static void tc358870_dsi_init(struct udevice *dev)
 	tc358870_write_u32(dev, DSI_PR_TO_COUNT,	0x00001000u);
 	tc358870_write_u32(dev, DSI_LRX_H_TO_COUNT,	0x00010000u);
 	tc358870_write_u32(dev, FUNC_MODE,		0x00000160u);
-	tc358870_write_u32(dev, DSIRX_VC_ENABLE,	0x00000001u);
+	tc358870_write_u32(dev, DSIRX_VC_ENABLE,	0x0000000fu);
 	tc358870_write_u32(dev, IND_TO_COUNT,		0x000000c8u);
 	tc358870_write_u32(dev, DSI_HSYNC_STOP_COUNT,	0x0000002au);
 	tc358870_write_u32(dev, DSITX_MODE,		0x00000081u);
@@ -397,6 +453,11 @@ static bool tc358870_match_ls055r1sx04(struct udevice *dev)
 	cleanup_free u8 *out = NULL;
 	ssize_t len;
 
+	len = tc358870_dsi_dcs_read(dev, 0, MIPI_DCS_GET_POWER_MODE, &out);
+	if (len > 0 && out != NULL) {
+		log_debug("%s: get_power_mode returned 0x%02x.\n", __func__, out[0]);
+		free(out);
+	}
 	tc358870_dsi_generic_write_short(dev, 0, 0xb0u, 0x00u);
 
 	len = tc358870_dsi_generic_read_short(dev, 0, 0xbfu, &out);
-- 
2.34.0


From 86db48758a250e7190136a3fef7dec083e8aa314 Mon Sep 17 00:00:00 2001
From: Roman Beranek <roman.beranek@prusa3d.com>
Date: Thu, 11 Feb 2021 09:56:38 +0100
Subject: [PATCH 3/3] tc358870: nvm write

---
 board/sunxi/Makefile                |   1 +
 board/sunxi/board.c                 |   6 +-
 board/sunxi/panel-detector-uclass.c | 245 ++++++++++++++++++++++
 board/sunxi/panel_detector.h        |  15 ++
 board/sunxi/tc358870.c              | 293 ++++++++++++++++++++++------
 lib/vsprintf.c                      |   8 +
 6 files changed, 511 insertions(+), 67 deletions(-)

diff --git a/board/sunxi/Makefile b/board/sunxi/Makefile
index d0cf81d7ff..15c1d6cbb1 100644
--- a/board/sunxi/Makefile
+++ b/board/sunxi/Makefile
@@ -19,6 +19,7 @@ obj-$(CONFIG_EFI_PARTITION)	+= grow_sd.o
 ifdef CONFIG_BRIDGED_PANEL_DETECTION
 obj-y	+= panel-detector-uclass.o
 obj-y	+= tc358870.o
+CFLAGS_panel-detector-uclass.o := -Wno-packed-bitfield-compat
 endif
 
 endif
diff --git a/board/sunxi/board.c b/board/sunxi/board.c
index 4767f4b1aa..441b01d12d 100644
--- a/board/sunxi/board.c
+++ b/board/sunxi/board.c
@@ -1074,10 +1074,8 @@ int ft_board_setup(void *blob, struct bd_info *bd)
 	offset = fdt_node_offset_by_compatible(blob, -1, "toshiba,tc358870");
 	if (offset < 0)
 		return offset;
-	r = fdt_setprop_string(blob, offset, "panel-name", panel_detector_get_panel_name(detector));
-	r = fdt_setprop_u64(blob, offset, "match-data", panel_detector_get_match_data(detector));
-	if (r)
-		return r;
+
+	panel_detector_fill_in_fdt_node(detector, blob, offset);
 #endif
 	return 0;
 }
diff --git a/board/sunxi/panel-detector-uclass.c b/board/sunxi/panel-detector-uclass.c
index 41eec54249..c9574aa479 100644
--- a/board/sunxi/panel-detector-uclass.c
+++ b/board/sunxi/panel-detector-uclass.c
@@ -5,8 +5,208 @@
  */
 
 #include <dm.h>
+#include <command.h>
+#include <vsprintf.h>
+#include <dm/device-internal.h>
 #include "panel_detector.h"
 
+typedef struct __attribute__((packed)) {
+	enum { CZP=0 } origin:4;
+	u32 sequence_number:20;
+	u8 week:6;
+	u8 year:8;
+	u16 ean_pn:10;
+} prusa_serial_number_t; /* 6 bytes */
+
+typedef union lcd_vendor_data {
+	struct __attribute__((packed)) {
+		u16 transmittance;
+		prusa_serial_number_t sn;
+	} structured;
+	u64 numeric;
+} lcd_vendor_data_t; /* 8 bytes */
+
+static enum command_ret_t handle_error(int err)
+{
+	if (err == CMD_RET_USAGE)
+		return CMD_RET_USAGE;
+
+	if (err < 0) {
+		printf("Command failed: Error %d\n", err);
+		return CMD_RET_FAILURE;
+	}
+
+	if (err == 0) {
+		printf("OK\n");
+		return CMD_RET_SUCCESS;
+	}
+
+	return CMD_RET_FAILURE;
+}
+
+static void sn_to_string(char* dst, prusa_serial_number_t const* sn) {
+	snprintf(dst, 20, "%3sX%02hhu%02hhuX%03huX%06u", "CZP",
+		 sn->week, sn->year, sn->ean_pn, sn->sequence_number);
+}
+
+static int parse_sn(prusa_serial_number_t *dst, char const* src)
+{
+	uint8_t week;
+	uint8_t year;
+	uint16_t ean;
+	uint32_t seq;
+
+	sscanf(src, "CZPX%02hhu%02hhuX%03huX%06u", &week, &year, &ean, &seq);
+
+	dst->origin = CZP;
+	dst->week = week;
+	dst->year = year;
+	dst->ean_pn = ean;
+	dst->sequence_number = seq;
+
+	char buf[20];
+	sn_to_string(buf, dst);
+	if (strncmp(src, buf, sizeof(buf)) != 0) return -EINVAL;
+	return 0;
+}
+
+static int load_vendor_data(struct udevice *dev)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	int r;
+	lcd_vendor_data_t data;
+
+	r = panel_detector_read_id_from_nvm(dev, &data.numeric);
+	if (r < 0)
+		return r;
+	sn_to_string(uc_priv->sn_str, &data.structured.sn);
+	uc_priv->transmittance = data.structured.transmittance;
+
+	return 0;
+}
+
+static int do_panel_id_is_writable(struct udevice *dev)
+{
+	int ret = panel_detector_has_writable_nvm(dev);
+	if (ret == 0) {
+		printf("The ID region of the OTP has already been written to.\n");
+		return 1;
+	} else if (ret == 1) {
+		printf("The ID region of the OTP is empty and writable.\n");
+		return 0;
+	}
+	return ret;
+}
+
+static int do_panel_id_read_qword(struct udevice *dev)
+{
+	int r;
+	u64 id;
+
+	r = panel_detector_read_id_from_nvm(dev, &id);
+	if (r < 0)
+		return r;
+	printf("ID = 0x%016llx\n", id);
+	return 0;
+}
+
+static int do_panel_id_write_qword(struct udevice *dev, char * const str_id)
+{
+	u64 id = simple_strtoull(str_id, NULL, 0x10);
+	return panel_detector_write_id_to_nvm(dev, id);
+}
+
+static int do_panel_id_read_vendor_data(struct udevice *dev)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	int ret;
+
+	ret = load_vendor_data(dev);
+	if (ret < 0) return ret;
+
+	int t = uc_priv->transmittance;
+	printf("SN = %s, transmittance = %d.%02d %%\n", uc_priv->sn_str, t/100, t%100);
+	return 0;
+}
+
+static int do_panel_id_write_vendor_data(struct udevice *dev, char * const sn_str,
+					 char * const transmittance_str)
+{
+	int ret;
+	lcd_vendor_data_t data;
+	ret = sscanf(transmittance_str, "%hu", &data.structured.transmittance);
+	if (ret != 1) {
+		printf("ERROR: couldn't parse TRANSMITTANCE argument\n");
+		return -EINVAL;
+	}
+	if (data.structured.transmittance > 10000) {
+		printf("ERROR: invalid transmittance value.\n");
+		return -EINVAL;
+	}
+
+	ret = parse_sn(&data.structured.sn, sn_str);
+	if (ret < 0) {
+		printf("ERROR: couldn't parse SN argument\n");
+		return ret;
+	}
+
+	return panel_detector_write_id_to_nvm(dev, data.numeric);
+}
+
+static int do_panel_id(struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
+{
+	int r;
+	struct udevice *dev;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	char * const cmd = argv[1];
+	argc -= 2;
+	argv += 2;
+
+	r = uclass_first_device(UCLASS_PANEL_DETECTOR, &dev);
+	if (r < 0)
+		return handle_error(r);
+
+	if (!strcmp(cmd, "remove") && argc == 0)
+		return handle_error(device_remove(dev, DM_REMOVE_NORMAL));
+	if (!strcmp(cmd, "is_writable") && argc == 0)
+		return handle_error(do_panel_id_is_writable(dev));
+	if (!strcmp(cmd, "read") && argc == 0)
+		return handle_error(do_panel_id_read_vendor_data(dev));
+	if (!strcmp(cmd, "read_qword") && argc == 0)
+		return handle_error(do_panel_id_read_qword(dev));
+	if (!strcmp(cmd, "write") && argc == 2)
+		return handle_error(do_panel_id_write_vendor_data(dev, argv[0], argv[1]));
+	if (!strcmp(cmd, "write_qword") && argc == 1)
+		return handle_error(do_panel_id_write_qword(dev, argv[0]));
+
+	return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	panel_id,	4,	1,	do_panel_id,
+	"Read/write ID stored in the OTP of an LCD panel",
+	"\nPOWER\n"
+	"panel_id remove                    Deinitialize panel and turn AVDD regulator off\n"
+	"                                   (the complementary operation (probe) happens\n"
+	"                                   automatically when a panel_id command is invoked)\n"
+	"\n"
+	"OTP\n"
+	"panel_id is_writable               Check that a panel hasn't yet been written to\n"
+	"panel_id read                      Read vendor data from the OTP\n"
+	"panel_id read_qword                Read OTP data as a 64-bit word \n"
+	"                                   (0x0020406080a0c0e0 is factory default)\n"
+	"panel_id write <sn> <x-mittance>   Write vendor data into the OTP\n"
+	"                                   SN expected as CZPX[wwyy]X[ean]X[serial]\n"
+	"                                   (i.e. CZPX1721X000X123456)\n"
+	"                                   and transmittance in units of 10^-4\n"
+	"                                   (i.e. an integer lying in the interval [0, 10000])\n"
+	"panel_id write_qword <qword>       Write a 64-bit word (number, actually) into the OTP\n"
+	""
+);
+
 const char* panel_detector_get_panel_name(struct udevice *dev)
 {
 	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
@@ -19,6 +219,51 @@ u64 panel_detector_get_match_data(struct udevice *dev)
 	return uc_priv->match_data;
 }
 
+int panel_detector_has_writable_nvm(struct udevice *dev)
+{
+	struct panel_detector_ops *ops = panel_detector_get_ops(dev);
+	if (!ops->has_writable_nvm)
+		return -ENOSYS;
+	return ops->has_writable_nvm(dev);
+}
+
+int panel_detector_write_id_to_nvm(struct udevice *dev, u64 id)
+{
+	struct panel_detector_ops *ops = panel_detector_get_ops(dev);
+	if (!ops->write_id_to_nvm)
+		return -ENOSYS;
+	return ops->write_id_to_nvm(dev, id);
+}
+
+int panel_detector_read_id_from_nvm(struct udevice *dev, u64 *id)
+{
+	struct panel_detector_ops *ops = panel_detector_get_ops(dev);
+	if (!ops->read_id_from_nvm)
+		return -ENOSYS;
+	return ops->read_id_from_nvm(dev, id);
+}
+
+int panel_detector_fill_in_fdt_node(struct udevice *dev, void *blob, int offset)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	int ret;
+	ret = fdt_setprop_string(blob, offset, "panel-name", uc_priv->panel_name);
+	if (ret < 0) return ret;
+	ret = fdt_setprop_u64(blob, offset, "match-data", uc_priv->match_data);
+	if (ret < 0) return ret;
+
+	if (strcmp(uc_priv->panel_name, "rv059fbb") != 0 || panel_detector_has_writable_nvm(dev))
+		return 0;
+
+	if (load_vendor_data(dev) < 0) return 0;
+	ret = fdt_setprop_string(blob, offset, "serial-number", uc_priv->sn_str);
+	if (ret < 0) return ret;
+	ret = fdt_setprop_u32(blob, offset, "transmittance", uc_priv->transmittance);
+	if (ret < 0) return ret;
+
+	return 0;
+}
+
 UCLASS_DRIVER(panel_detector) = {
 	.id			= UCLASS_PANEL_DETECTOR,
 	.name			= "panel_detector",
diff --git a/board/sunxi/panel_detector.h b/board/sunxi/panel_detector.h
index 65294be844..fa86b81410 100644
--- a/board/sunxi/panel_detector.h
+++ b/board/sunxi/panel_detector.h
@@ -10,9 +10,24 @@
 struct panel_detector_priv {
 	char const* panel_name;
 	u64 match_data;
+	char sn_str[22];
+	u16 transmittance;
 };
 
+struct panel_detector_ops {
+	int (*has_writable_nvm)(struct udevice* dev);
+	int (*write_id_to_nvm)(struct udevice* dev, u64 id);
+	int (*read_id_from_nvm)(struct udevice* dev, u64 *id);
+};
+
+#define panel_detector_get_ops(dev) \
+		((struct panel_detector_ops *)(dev)->driver->ops)
+
 const char* panel_detector_get_panel_name(struct udevice *dev);
 u64 panel_detector_get_match_data(struct udevice *dev);
+int panel_detector_has_writable_nvm(struct udevice *dev);
+int panel_detector_write_id_to_nvm(struct udevice *dev, u64 id);
+int panel_detector_read_id_from_nvm(struct udevice *dev, u64 *id);
+int panel_detector_fill_in_fdt_node(struct udevice *dev, void *blob, int offset);
 
 #endif
diff --git a/board/sunxi/tc358870.c b/board/sunxi/tc358870.c
index 191895df50..cf05a51036 100644
--- a/board/sunxi/tc358870.c
+++ b/board/sunxi/tc358870.c
@@ -19,15 +19,33 @@
 #include "panel_detector.h"
 #include "tc358870.h"
 
+static const char RV059FBB[] = "rv059fbb";
+
 static inline void freep(void *p) {
 	free(*(void**) p);
 }
+
+static inline void free_gpiop(struct gpio_desc *desc) {
+	if (desc->dev == NULL) return;
+	dm_gpio_set_value(desc, true);
+	dm_gpio_free(desc->dev, desc);
+	desc->dev = NULL;
+}
+
+static inline void disable_regp(struct udevice **regp) {
+	if (*regp == NULL) return;
+	regulator_set_enable(*regp, false);
+}
+
 #define cleanup(x) __attribute__((__cleanup__(x)))
 #define cleanup_free cleanup(freep)
+#define cleanup_gpio cleanup(free_gpiop)
+#define cleanup_reg cleanup(disable_regp)
 
 struct tc358870_priv {
 	struct gpio_desc bridge_reset;
 	struct gpio_desc panel_reset;
+	struct udevice *lcd_reg;
 	u8 vc;
 };
 
@@ -128,18 +146,6 @@ static int tc358870_write_u32(struct udevice *dev, u16 reg_addr, u32 value)
 	return tc358870_write(dev, reg_addr, &value, sizeof(value));
 }
 
-#if 0
-static int tc358870_read_u16(struct udevice *dev, u16 reg_addr, u16 *value)
-{
-	int ret = tc358870_read(dev, reg_addr, value, sizeof(*value));
-	if (ret < 0) {
-		return ret;
-	}
-	le16_to_cpus(value);
-	return 0;
-}
-#endif
-
 static int tc358870_read_u32(struct udevice *dev, u16 reg_addr, u32 *value)
 {
 	int ret;
@@ -151,37 +157,6 @@ static int tc358870_read_u32(struct udevice *dev, u16 reg_addr, u32 *value)
 	return 0;
 }
 
-#if 0 /* TODO: Why does RX_STATE_INT_STAT stay 0? */
-static int tc358870_wait_for_lprx_done(struct udevice *dev, u8 iface)
-{
-#define LPRX_PKT_START		(1u << 3u)
-#define LPRX_PKT_DONE		(1u << 2u)
-#define LPRX_PKT_THRESH_HIT	(1u << 1u)
-	int i, ret = 0;
-	u32 mask = LPRX_PKT_START | LPRX_PKT_DONE | LPRX_PKT_THRESH_HIT;
-	u32 out = 0;
-	for (i = 50; ((out & LPRX_PKT_DONE) == 0) && (i > 0) && (ret >= 0); i--)
-	{
-		ret = tc358870_read_u32(dev, RX_STATE_INT_STAT + iface * 0x0200u, &out);
-		mdelay(5);
-	}
-	if (ret < 0) {
-		log_err("%s: read error %d\n", __func__, ret);
-		return ret;
-	}
-	if ((out & mask) == 0) {
-		log_err("%s: waiting for LPRX packet reception timed out\n", __func__);
-		return 0;
-	}
-	if (!(out & LPRX_PKT_DONE)) {
-		log_err("%s: not DONE yet!\n", __func__);
-	}
-	/* clear out the interrupt register */
-	tc358870_write_u32(dev, RX_STATE_INT_STAT + iface * 0x0200u, mask);
-	return 0;
-}
-#endif
-
 static ssize_t tc358770_fetch_from_fifo(struct udevice *dev, u8 iface, u8* data, int word_count)
 {
 	int i, len;
@@ -519,6 +494,8 @@ static int tc358870_panel_init(struct udevice *dev)
 		log_err("Couldn't identify any panel connected to the bridge.\n");
 	}
 
+	log_info("Detected panel: %s\n", uc_priv->panel_name);
+
 	return 0;
 }
 
@@ -568,37 +545,215 @@ static int tc358870_enable(struct udevice *dev)
 	return 0;
 }
 
+static int tc358870_reset(struct udevice *dev)
+{
+	struct tc358870_priv *priv = dev_get_priv(dev);
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+
+	uc_priv->panel_name = "";
+	regulator_set_enable(priv->lcd_reg, false);
+	mdelay(10);
+	regulator_set_enable(priv->lcd_reg, true);
+	return tc358870_enable(dev);
+}
+
+struct rv059fbb_nvm {
+	struct udevice *dev;
+};
+
+static bool tc358870_is_rv059fbb_connected(struct udevice *dev)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	return strncmp(uc_priv->panel_name, RV059FBB, sizeof(RV059FBB)) == 0;
+}
+
+static struct rv059fbb_nvm* rv059fbb_nvm_alloc(struct udevice *dev)
+{
+	if (!tc358870_is_rv059fbb_connected(dev))
+		return NULL;
+
+	struct rv059fbb_nvm* nvm = malloc(sizeof(struct rv059fbb_nvm));
+	nvm->dev = dev;
+	tc358870_dsi_dcs_write(dev, 1, MIPI_DCS_EXIT_SLEEP_MODE);
+	mdelay(25);
+
+	tc358870_dsi_generic_write_short(dev, 1, 0xb0u, 0x00u); /* Switch to page 0 */
+	tc358870_dsi_generic_write_short(dev, 1, 0xbau, 0x4bu); /* Enable VDD_OTP_SW */
+	tc358870_dsi_generic_write_short(dev, 1, 0xc0u, 0x94u); /* Enable VDD_OTP_EN */
+	tc358870_dsi_generic_write_short(dev, 1, 0xb0u, 0x01u); /* Switch to page 1 */
+	tc358870_dsi_generic_write_short(dev, 1, 0xb2u, 0xa5u); /* Set password to 'A5h' */
+
+	return nvm;
+}
+
+static void rv059fbb_nvm_free(struct rv059fbb_nvm *nvm)
+{
+	if (nvm == NULL) return;
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x00u); /* Switch to page 0 */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xbau, 0x43u); /* Disable VDD_OTP_SW */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xc0u, 0x14u); /* Disable VDD_OTP_EN */
+	free(nvm);
+}
+
+static void rv059fbb_nvm_freep(struct rv059fbb_nvm **p_nvm)
+{
+	if (p_nvm == NULL) return;
+	rv059fbb_nvm_free(*p_nvm);
+	*p_nvm = NULL;
+}
+
+static int rv059fbb_nvm_write_id(struct rv059fbb_nvm *nvm, u64 value)
+{
+	u8 reg[14] = {
+		0x39, 0x21, 0xff, 0x10, 0x00, 0x02,		/* Default values */
+	};
+
+	cpu_to_be64s(&value);
+	memcpy(reg + 6, &value, sizeof(value));
+
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x04u); /* Switch to page 4 */
+	tc358870_dsi_generic_write_long(nvm->dev, 1, 0xb1u, reg, sizeof(reg)); /* Set B1 function register */
+
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x01u); /* Switch to page 1 */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb1u, 0x0eu); /* Select OTP group 14 */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb3u, 0x01u); /* Start auto-write */
+	mdelay(25);
+
+	return 0;
+}
+
+static int rv059fbb_nvm_read_id(struct rv059fbb_nvm *nvm, u64 *id)
+{
+	cleanup_free u8 *out = NULL;
+	ssize_t len;
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x04u); /* Switch to page 4 */
+	len = tc358870_dsi_generic_read_short(nvm->dev, 1, 0xb1u, &out);
+
+	if (len < 14) return -EINVAL;
+	memcpy(id, out + 6, sizeof(*id));
+	be64_to_cpus(id);
+	return 0;
+}
+
+static u8 rv059fbb_nvm_read_otp(struct rv059fbb_nvm *nvm, u16 index)
+{
+	cleanup_free u8 *out = NULL;
+	ssize_t len;
+
+	if (index > 1008) return 0;
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x01u); /* Switch to page 4 */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb4u, (u8)(index >> 8u)); /* Upper bits of OTP index */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb5u, index & 0xffu); /* Lower bits of OTP index */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb3u, 0x02u); /* Start read */
+	udelay(10);
+	len = tc358870_dsi_generic_read_short(nvm->dev, 1, 0xb6u, &out);
+	if (len < 1) return 0;
+	return out[0];
+}
+
+static int rv059fbb_nvm_is_writable(struct rv059fbb_nvm *nvm)
+{
+	u8 out = rv059fbb_nvm_read_otp(nvm, 432);
+	return !(out >> 7); /* the highest bit is 1 if written */
+}
+
+static int tc358870_has_writable_nvm(struct udevice *dev)
+{
+	if (!tc358870_is_rv059fbb_connected(dev))
+		return -ENODEV;
+
+	cleanup(rv059fbb_nvm_freep) struct rv059fbb_nvm* nvm = rv059fbb_nvm_alloc(dev);
+	if (nvm == NULL)
+		return -EACCES;
+
+	return rv059fbb_nvm_is_writable(nvm);
+}
+
+static int tc358870_write_id_to_nvm(struct udevice *dev, u64 id)
+{
+	int ret;
+	u64 read_id;
+	if (!tc358870_is_rv059fbb_connected(dev))
+		return -ENODEV;
+
+	cleanup(rv059fbb_nvm_freep) struct rv059fbb_nvm* nvm = rv059fbb_nvm_alloc(dev);
+	if (nvm == NULL)
+		return -EACCES;
+	ret = rv059fbb_nvm_write_id(nvm, id);
+	if (ret < 0)
+		return -EFAULT;
+
+	rv059fbb_nvm_free(nvm);
+	ret = tc358870_reset(dev);
+	if (ret < 0)
+		return -ERESTART;
+	nvm = rv059fbb_nvm_alloc(dev);
+	ret = rv059fbb_nvm_read_id(nvm, &read_id);
+	if (ret < 0)
+		return -EIO;
+	if (id != read_id) {
+		log_warning("The OTP has already been written.\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int tc358870_read_id_from_nvm(struct udevice *dev, u64 *id)
+{
+	int ret;
+	if (!tc358870_is_rv059fbb_connected(dev))
+		return -ENODEV;
+
+	cleanup(rv059fbb_nvm_freep) struct rv059fbb_nvm* nvm = rv059fbb_nvm_alloc(dev);
+	if (nvm == NULL)
+		return -EACCES;
+
+	ret = rv059fbb_nvm_read_id(nvm, id);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct panel_detector_ops tc358870_ops = {
+	.has_writable_nvm = tc358870_has_writable_nvm,
+	.write_id_to_nvm = tc358870_write_id_to_nvm,
+	.read_id_from_nvm = tc358870_read_id_from_nvm,
+};
+
 static int tc358870_probe(struct udevice *dev)
 {
 	int ret;
-	struct udevice *reg;
 
 	struct tc358870_priv *priv = dev_get_priv(dev);
 	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
 
+	cleanup_reg struct udevice *lcd_reg = NULL;
+	cleanup_gpio struct gpio_desc panel_reset;
+	cleanup_gpio struct gpio_desc bridge_reset;
+
 	if (device_get_uclass_id(dev->parent) != UCLASS_I2C)
 		return -EPROTONOSUPPORT;
 
-	ret = gpio_request_by_name(dev, "bridge-reset-gpios", 0, &priv->bridge_reset,
+	ret = gpio_request_by_name(dev, "bridge-reset-gpios", 0, &bridge_reset,
 				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
 	if (ret) {
 		log_err("%s: Could not decode bridge-reset-gpios (%d)\n", __func__, ret);
-		if (ret != -ENOENT)
-			return ret;
+		return ret;
 	}
 
-	ret = gpio_request_by_name(dev, "panel-reset-gpios", 0, &priv->panel_reset,
+	ret = gpio_request_by_name(dev, "panel-reset-gpios", 0, &panel_reset,
 				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
 	if (ret) {
 		log_err("%s: Could not decode panel-reset-gpios (%d)\n", __func__, ret);
-		if (ret != -ENOENT)
-			return ret;
+		return ret;
 	}
 
 	ret = uclass_get_device_by_phandle(UCLASS_REGULATOR, dev,
-					   "avdd_lcd-supply", &reg);
+					   "avdd_lcd-supply", &lcd_reg);
 	if (!ret) {
-		ret = regulator_set_enable(reg, true);
+		ret = regulator_set_enable(lcd_reg, true);
 		if (ret < 0) {
 			log_err("%s: Failed to enable power: ret=%d\n", __func__, ret);
 			return ret;
@@ -608,8 +763,37 @@ static int tc358870_probe(struct udevice *dev)
 		return ret;
 	}
 
+	priv->bridge_reset = bridge_reset;
+	priv->panel_reset = panel_reset;
 	uc_priv->panel_name = "";
-	return tc358870_enable(dev);
+
+	ret = tc358870_enable(dev);
+	if (ret >= 0) {
+		priv->lcd_reg = lcd_reg;
+		/* prevent cleanup */
+		bridge_reset.dev = NULL;
+		panel_reset.dev = NULL;
+		lcd_reg = NULL;
+	}
+	return ret;
+}
+
+static int tc358870_disable(struct udevice *dev)
+{
+	struct tc358870_priv *priv = dev_get_priv(dev);
+	dm_gpio_set_value(&priv->bridge_reset, true);
+	dm_gpio_set_value(&priv->panel_reset, true);
+	regulator_set_enable(priv->lcd_reg, false);
+	return 0;
+}
+
+static int tc358870_remove(struct udevice *dev)
+{
+	struct tc358870_priv *priv = dev_get_priv(dev);
+	tc358870_disable(dev);
+	free_gpiop(&priv->bridge_reset);
+	free_gpiop(&priv->panel_reset);
+	return 0;
 }
 
 static const struct udevice_id tc358870_ids[] = {
@@ -621,6 +805,9 @@ U_BOOT_DRIVER(toshiba_tc358870) = {
 	.name	= "toshiba_tc358870",
 	.id	= UCLASS_PANEL_DETECTOR,
 	.of_match = tc358870_ids,
+	.ops	= &tc358870_ops,
 	.probe	= tc358870_probe,
+	.remove = tc358870_remove,
 	.priv_auto = sizeof(struct tc358870_priv),
 };
+
diff --git a/lib/vsprintf.c b/lib/vsprintf.c
index 9dc96c81c6..bea17c8278 100644
--- a/lib/vsprintf.c
+++ b/lib/vsprintf.c
@@ -597,6 +597,10 @@ repeat:
 				qualifier = 'L';
 				++fmt;
 			}
+			if (qualifier == 'h' && *fmt == 'h') {
+				qualifier = 'H';
+				++fmt;
+			}
 		}
 
 		/* default base */
@@ -691,6 +695,10 @@ repeat:
 			num = (unsigned short) va_arg(args, int);
 			if (flags & SIGN)
 				num = (signed short) num;
+		} else if (qualifier == 'H') {
+			num = (unsigned char) va_arg(args, int);
+			if (flags & SIGN)
+				num = (signed char) num;
 		} else {
 			num = va_arg(args, unsigned int);
 			if (flags & SIGN)
-- 
2.34.0
