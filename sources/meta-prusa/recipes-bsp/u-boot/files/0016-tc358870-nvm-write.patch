From 7e7983813303b5b457b8ce3ef48c8bf10895cb98 Mon Sep 17 00:00:00 2001
From: Roman Beranek <roman.beranek@prusa3d.com>
Date: Thu, 11 Feb 2021 09:56:38 +0100
Subject: [PATCH] tc358870: nvm write

---
 board/sunxi/panel-detector-uclass.c |  92 ++++++++++
 board/sunxi/panel_detector.h        |  12 ++
 board/sunxi/tc358870.c              | 267 +++++++++++++++++++++-------
 3 files changed, 310 insertions(+), 61 deletions(-)

diff --git a/board/sunxi/panel-detector-uclass.c b/board/sunxi/panel-detector-uclass.c
index e37231e8f8..c6ed7b62d4 100644
--- a/board/sunxi/panel-detector-uclass.c
+++ b/board/sunxi/panel-detector-uclass.c
@@ -5,6 +5,7 @@
  */
 
 #include <dm.h>
+#include <command.h>
 #include "panel_detector.h"
 
 const char* panel_detector_get_panel_name(struct udevice *dev)
@@ -19,8 +20,99 @@ u64 panel_detector_get_match_data(struct udevice *dev)
 	return uc_priv->match_data;
 }
 
+int panel_detector_has_writable_nvm(struct udevice *dev)
+{
+	struct panel_detector_ops *ops = panel_detector_get_ops(dev);
+	if (!ops->has_writable_nvm)
+		return -ENOSYS;
+	return ops->has_writable_nvm(dev);
+}
+
+int panel_detector_write_id_to_nvm(struct udevice *dev, u64 id)
+{
+	struct panel_detector_ops *ops = panel_detector_get_ops(dev);
+	if (!ops->has_writable_nvm)
+		return -ENOSYS;
+	return ops->write_id_to_nvm(dev, id);
+}
+
+int panel_detector_read_id_from_nvm(struct udevice *dev, u64 *id)
+{
+	struct panel_detector_ops *ops = panel_detector_get_ops(dev);
+	if (!ops->has_writable_nvm)
+		return -ENOSYS;
+	return ops->read_id_from_nvm(dev, id);
+}
+
 UCLASS_DRIVER(panel_detector) = {
 	.id				= UCLASS_PANEL_DETECTOR,
 	.name				= "panel_detector",
 	.per_device_auto_alloc_size	= sizeof(struct panel_detector_priv),
 };
+
+static enum command_ret_t handle_error(int err)
+{
+	if (err == CMD_RET_USAGE)
+		return CMD_RET_USAGE;
+
+	if (err) {
+		printf("Command failed: Error %d\n", err);
+		return CMD_RET_FAILURE;
+	}
+
+	printf("OK\n");
+	return CMD_RET_SUCCESS;
+}
+
+static int do_panel_id_read(struct udevice *dev)
+{
+	int r;
+	u64 id;
+
+	r = panel_detector_read_id_from_nvm(dev, &id);
+	if (r < 0)
+		return r;
+	printf("ID = 0x%016llx\n", id);
+	return 0;
+}
+
+static int do_panel_id_write(struct udevice *dev, char * const str_id)
+{
+	u64 id = simple_strtoull(str_id, NULL, 0x10);
+	return panel_detector_write_id_to_nvm(dev, id);
+}
+
+static int do_panel_id(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int r;
+	struct udevice *dev;
+
+	if (argc < 1)
+		return CMD_RET_USAGE;
+
+	char * const cmd = argv[1];
+	argc -= 2;
+	argv += 2;
+
+	r = uclass_first_device(UCLASS_PANEL_DETECTOR, &dev);
+	if (r < 0)
+		return handle_error(r);
+
+	if (!strcmp(cmd, "is_writable") && argc == 0)
+		return panel_detector_has_writable_nvm(dev);
+	else if (!strcmp(cmd, "read") && argc == 0)
+		return handle_error(do_panel_id_read(dev));
+	else if (!strcmp(cmd, "write") && argc == 1)
+		return handle_error(do_panel_id_write(dev, argv[0]));
+
+	return CMD_RET_USAGE;
+}
+
+U_BOOT_CMD(
+	panel_id,	3,	1,	do_panel_id,
+	"Read/write ID stored in the NVM of an LCD panel",
+	"panel_id is_writable     Check whether a suitable panel is connected\n"
+	"panel_id read            Read 64-bit ID stored in NVM (default: 0x0020406080a0c0e0)\n"
+	"panel_id write <id>      Write 64-bit ID into NVM\n"
+ 	""
+);
diff --git a/board/sunxi/panel_detector.h b/board/sunxi/panel_detector.h
index 65294be844..1e8b2e76ba 100644
--- a/board/sunxi/panel_detector.h
+++ b/board/sunxi/panel_detector.h
@@ -12,7 +12,19 @@ struct panel_detector_priv {
 	u64 match_data;
 };
 
+struct panel_detector_ops {
+	int (*has_writable_nvm)(struct udevice* dev);
+	int (*write_id_to_nvm)(struct udevice* dev, u64 id);
+	int (*read_id_from_nvm)(struct udevice* dev, u64 *id);
+};
+
+#define panel_detector_get_ops(dev) \
+		((struct panel_detector_ops *)(dev)->driver->ops)
+
 const char* panel_detector_get_panel_name(struct udevice *dev);
 u64 panel_detector_get_match_data(struct udevice *dev);
+int panel_detector_has_writable_nvm(struct udevice *dev);
+int panel_detector_write_id_to_nvm(struct udevice *dev, u64 id);
+int panel_detector_read_id_from_nvm(struct udevice *dev, u64 *id);
 
 #endif
diff --git a/board/sunxi/tc358870.c b/board/sunxi/tc358870.c
index a85c423016..513337b2cc 100644
--- a/board/sunxi/tc358870.c
+++ b/board/sunxi/tc358870.c
@@ -18,15 +18,33 @@
 #include "panel_detector.h"
 #include "tc358870.h"
 
+static const char RV059FBB[] = "rv059fbb";
+
 static inline void kfreep(void *p) {
 	kfree(*(void**) p);
 }
+
+static inline void free_gpiop(struct gpio_desc *desc) {
+	if (desc->dev == NULL) return;
+	dm_gpio_set_value(desc, true);
+	dm_gpio_free(desc->dev, desc);
+	desc->dev = NULL;
+}
+
+static inline void disable_regp(struct udevice **regp) {
+	if (*regp == NULL) return;
+	regulator_set_enable(*regp, false);
+}
+
 #define cleanup(x) __attribute__((__cleanup__(x)))
 #define cleanup_free cleanup(kfreep)
+#define cleanup_gpio cleanup(free_gpiop)
+#define cleanup_reg cleanup(disable_regp)
 
 struct tc358870_priv {
 	struct gpio_desc bridge_reset;
 	struct gpio_desc panel_reset;
+	struct udevice *lcd_reg;
 	u8 vc;
 };
 
@@ -127,18 +145,6 @@ static int tc358870_write_u32(struct udevice *dev, u16 reg_addr, u32 value)
 	return tc358870_write(dev, reg_addr, &value, sizeof(value));
 }
 
-#if 0
-static int tc358870_read_u16(struct udevice *dev, u16 reg_addr, u16 *value)
-{
-	int ret = tc358870_read(dev, reg_addr, value, sizeof(*value));
-	if (ret < 0) {
-		return ret;
-	}
-	le16_to_cpus(value);
-	return 0;
-}
-#endif
-
 static int tc358870_read_u32(struct udevice *dev, u16 reg_addr, u32 *value)
 {
 	int ret;
@@ -150,37 +156,6 @@ static int tc358870_read_u32(struct udevice *dev, u16 reg_addr, u32 *value)
 	return 0;
 }
 
-#if 0 /* TODO: Why does RX_STATE_INT_STAT stay 0? */
-static int tc358870_wait_for_lprx_done(struct udevice *dev, u8 iface)
-{
-#define LPRX_PKT_START		(1u << 3u)
-#define LPRX_PKT_DONE		(1u << 2u)
-#define LPRX_PKT_THRESH_HIT	(1u << 1u)
-	int i, ret = 0;
-	u32 mask = LPRX_PKT_START | LPRX_PKT_DONE | LPRX_PKT_THRESH_HIT;
-	u32 out = 0;
-	for (i = 50; ((out & LPRX_PKT_DONE) == 0) && (i > 0) && (ret >= 0); i--)
-	{
-		ret = tc358870_read_u32(dev, RX_STATE_INT_STAT + iface * 0x0200u, &out);
-		mdelay(5);
-	}
-	if (ret < 0) {
-		dev_err(dev, "%s: read error %d\n", __func__, ret);
-		return ret;
-	}
-	if ((out & mask) == 0) {
-		dev_err(dev, "%s: waiting for LPRX packet reception timed out\n", __func__);
-		return 0;
-	}
-	if (!(out & LPRX_PKT_DONE)) {
-		dev_err(dev, "%s: not DONE yet!\n", __func__);
-	}
-	/* clear out the interrupt register */
-	tc358870_write_u32(dev, RX_STATE_INT_STAT + iface * 0x0200u, mask);
-	return 0;
-}
-#endif
-
 static ssize_t tc358770_fetch_from_fifo(struct udevice *dev, u8 iface, u8* data, int word_count)
 {
 	int i, len;
@@ -461,17 +436,17 @@ static bool tc358870_match_ls055r1sx04(struct udevice *dev)
 
 	len = tc358870_dsi_generic_read_short(dev, 0, 0xbfu, &out);
 	if (len <= 0 || !out) {
-		dev_err(dev, "%s: DSI read from BFh address failed (%ld)\n", __func__, len);
+		dev_warn(dev, "%s: DSI read from BFh address failed (%ld)\n", __func__, len);
 		return false;
 	}
 	tc358870_save_match_data(dev, out, len);
 	if (len >= sizeof(ALMID) && memcmp(out, ALMID, sizeof(ALMID)) == 0) {
-		printf("%s: matched ALMID: SHARP LS055R1SX04\n", __func__);
+		dev_info("%s: matched ALMID: SHARP LS055R1SX04\n", __func__);
 		return true;
 	}
-	dev_err(dev, "%s: ALMID doesn't match an R63419 driver.\n", __func__);
+	dev_warn(dev, "%s: ALMID doesn't match an R63419 driver.\n", __func__);
 	if (len == 0x1f) {
-		dev_err(dev, "%s: response length is correct though: PASS\n", __func__);
+		dev_warn(dev, "%s: response length is correct though: PASS\n", __func__);
 		return true;
 	}
 	return false;
@@ -486,20 +461,20 @@ static bool tc358870_match_rv059fbb(struct udevice *dev)
 	len = tc358870_dsi_dcs_read(dev, 1, 0xa1u, &out);
 
 	if (len <= 0 || !out) {
-		printf("%s: DSI read from A1h address failed\n", __func__);
+		dev_warn("%s: DSI read from A1h address failed\n", __func__);
 		return false;
 	}
 	tc358870_save_match_data(dev, out, len);
 	if (len >= sizeof(ID) && memcmp(out, ID, sizeof(ID)) == 0) {
-		printf("%s: matched RV059FBB by descriptor block (112233445566)\n", __func__);
+		dev_info("%s: matched RV059FBB by descriptor block (112233445566)\n", __func__);
 		return true;
 	}
 	if (out[6] == 0xffu) {
-		printf("%s: matched RV059FBB by Exit Code (0xff) at the end of A1h response\n", __func__);
+		dev_warn("%s: matched RV059FBB by Exit Code (0xff) at the end of A1h response\n", __func__);
 		return true;
 	}
 	if (len == 7) {
-		printf("%s: matched RV059FBB by the length (7) of its response to A1h\n", __func__);
+		dev_warn("%s: matched RV059FBB by the length (7) of its response to A1h\n", __func__);
 		return true;
 	}
 
@@ -567,37 +542,186 @@ static int tc358870_enable(struct udevice *dev)
 	return 0;
 }
 
+static int tc358870_reset(struct udevice *dev)
+{
+	struct tc358870_priv *priv = dev_get_priv(dev);
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+
+	uc_priv->panel_name = "";
+	regulator_set_enable(priv->lcd_reg, false);
+	mdelay(10);
+	regulator_set_enable(priv->lcd_reg, true);
+	return tc358870_enable(dev);
+}
+
+struct rv059fbb_nvm {
+	struct udevice *dev;
+};
+
+static bool tc358870_is_rv059fbb_connected(struct udevice *dev)
+{
+	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
+	return strncmp(uc_priv->panel_name, RV059FBB, sizeof(RV059FBB)) == 0;
+}
+
+static struct rv059fbb_nvm* rv059fbb_nvm_alloc(struct udevice *dev)
+{
+	if (!tc358870_is_rv059fbb_connected(dev))
+		return NULL;
+
+	struct rv059fbb_nvm* nvm = kmalloc(sizeof(struct rv059fbb_nvm), GFP_KERNEL);
+	nvm->dev = dev;
+	tc358870_dsi_dcs_write(dev, 1, MIPI_DCS_EXIT_SLEEP_MODE);
+	mdelay(25);
+
+	tc358870_dsi_generic_write_short(dev, 1, 0xb0u, 0x00u); /* Switch to page 0 */
+	tc358870_dsi_generic_write_short(dev, 1, 0xbau, 0x4bu); /* Enable VDD_OTP_SW */
+	tc358870_dsi_generic_write_short(dev, 1, 0xc0u, 0x94u); /* Enable VDD_OTP_EN */
+	tc358870_dsi_generic_write_short(dev, 1, 0xb0u, 0x01u); /* Switch to page 1 */
+	tc358870_dsi_generic_write_short(dev, 1, 0xb2u, 0xa5u); /* Set password to 'A5h' */
+
+	return nvm;
+}
+
+static void rv059fbb_nvm_free(struct rv059fbb_nvm *nvm)
+{
+	if (nvm == NULL) return;
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x00u); /* Switch to page 0 */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xbau, 0x43u); /* Disable VDD_OTP_SW */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xc0u, 0x14u); /* Disable VDD_OTP_EN */
+	kfree(nvm);
+}
+
+static void rv059fbb_nvm_freep(struct rv059fbb_nvm **p_nvm)
+{
+	if (p_nvm == NULL) return;
+	rv059fbb_nvm_free(*p_nvm);
+	*p_nvm = NULL;
+}
+
+static int rv059fbb_nvm_write_id(struct rv059fbb_nvm *nvm, u64 value)
+{
+	u8 reg[14] = {
+		0x39, 0x21, 0xff, 0x10, 0x00, 0x02,		/* Default values */
+	};
+
+	cpu_to_be64s(&value);
+	memcpy(reg + 6, &value, sizeof(value));
+
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x04u); /* Switch to page 4 */
+	tc358870_dsi_generic_write_long(nvm->dev, 1, 0xb1u, reg, sizeof(reg)); /* Set B1 function register */
+
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x01u); /* Switch to page 1 */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb1u, 0x0eu); /* Select OTP group 14 */
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb3u, 0x01u); /* Start auto-write */
+	mdelay(25);
+
+	return 0;
+}
+
+static int rv059fbb_nvm_read_id(struct rv059fbb_nvm *nvm, u64 *id)
+{
+	cleanup_free u8 *out = NULL;
+	ssize_t len;
+	tc358870_dsi_generic_write_short(nvm->dev, 1, 0xb0u, 0x04u); /* Switch to page 4 */
+	len = tc358870_dsi_generic_read_short(nvm->dev, 1, 0xb1u, &out);
+
+	if (len < 14) return -EINVAL;
+	memcpy(id, out + 6, sizeof(*id));
+	be64_to_cpus(id);
+	return 0;
+}
+
+static int tc358870_has_writable_nvm(struct udevice *dev)
+{
+	return tc358870_is_rv059fbb_connected(dev) ? 0 : 1;
+}
+
+static int tc358870_write_id_to_nvm(struct udevice *dev, u64 id)
+{
+	int ret;
+	u64 read_id;
+	if (!tc358870_is_rv059fbb_connected(dev))
+		return -ENODEV;
+
+	cleanup(rv059fbb_nvm_freep) struct rv059fbb_nvm* nvm = rv059fbb_nvm_alloc(dev);
+	if (nvm == NULL)
+		return -EACCES;
+	ret = rv059fbb_nvm_write_id(nvm, id);
+	if (ret < 0)
+		return -EFAULT;
+
+	rv059fbb_nvm_free(nvm);
+	ret = tc358870_reset(dev);
+	if (ret < 0)
+		return -ERESTART;
+	nvm = rv059fbb_nvm_alloc(dev);
+	ret = rv059fbb_nvm_read_id(nvm, &read_id);
+	if (ret < 0)
+		return -EIO;
+	if (id != read_id) {
+		printf("The OTP has already been written.\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int tc358870_read_id_from_nvm(struct udevice *dev, u64 *id)
+{
+	int ret;
+	if (!tc358870_is_rv059fbb_connected(dev))
+		return -ENODEV;
+
+	cleanup(rv059fbb_nvm_freep) struct rv059fbb_nvm* nvm = rv059fbb_nvm_alloc(dev);
+	if (nvm == NULL)
+		return -EACCES;
+
+	ret = rv059fbb_nvm_read_id(nvm, id);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static const struct panel_detector_ops tc358870_ops = {
+	.has_writable_nvm = tc358870_has_writable_nvm,
+	.write_id_to_nvm = tc358870_write_id_to_nvm,
+	.read_id_from_nvm = tc358870_read_id_from_nvm,
+};
+
 static int tc358870_probe(struct udevice *dev)
 {
 	int ret;
-	struct udevice *reg;
 
 	struct tc358870_priv *priv = dev_get_priv(dev);
 	struct panel_detector_priv *uc_priv = dev_get_uclass_priv(dev);
 
+	cleanup_reg struct udevice *lcd_reg = NULL;
+	cleanup_gpio struct gpio_desc panel_reset;
+	cleanup_gpio struct gpio_desc bridge_reset;
+
 	if (device_get_uclass_id(dev->parent) != UCLASS_I2C)
 		return -EPROTONOSUPPORT;
 
-	ret = gpio_request_by_name(dev, "bridge-reset-gpios", 0, &priv->bridge_reset,
+	ret = gpio_request_by_name(dev, "bridge-reset-gpios", 0, &bridge_reset,
 				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
 	if (ret) {
 		dev_err(dev, "%s: Could not decode bridge-reset-gpios (%d)\n", __func__, ret);
-		if (ret != -ENOENT)
-			return ret;
+		return ret;
 	}
 
-	ret = gpio_request_by_name(dev, "panel-reset-gpios", 0, &priv->panel_reset,
+	ret = gpio_request_by_name(dev, "panel-reset-gpios", 0, &panel_reset,
 				   GPIOD_IS_OUT | GPIOD_IS_OUT_ACTIVE);
 	if (ret) {
 		dev_err(dev, "%s: Could not decode panel-reset-gpios (%d)\n", __func__, ret);
-		if (ret != -ENOENT)
-			return ret;
+		return ret;
 	}
 
 	ret = uclass_get_device_by_phandle(UCLASS_REGULATOR, dev,
-					   "avdd_lcd-supply", &reg);
+					   "avdd_lcd-supply", &lcd_reg);
 	if (!ret) {
-		ret = regulator_set_enable(reg, true);
+		ret = regulator_set_enable(lcd_reg, true);
 		if (ret < 0) {
 			dev_err(dev, "%s: Failed to enable power: ret=%d\n", __func__, ret);
 			return ret;
@@ -607,8 +731,27 @@ static int tc358870_probe(struct udevice *dev)
 		return ret;
 	}
 
+	priv->bridge_reset = bridge_reset;
+	priv->panel_reset = panel_reset;
 	uc_priv->panel_name = "";
-	return tc358870_enable(dev);
+
+	ret = tc358870_enable(dev);
+	if (ret >= 0) {
+		bridge_reset.dev = NULL;
+		panel_reset.dev = NULL;
+		priv->lcd_reg = lcd_reg;
+		lcd_reg = NULL;
+	}
+	return ret;
+}
+
+static int tc358870_remove(struct udevice *dev)
+{
+	struct tc358870_priv *priv = dev_get_priv(dev);
+	dm_gpio_set_value(&priv->bridge_reset, true);
+	dm_gpio_set_value(&priv->panel_reset, true);
+	regulator_set_enable(priv->lcd_reg, false);
+	return 0;
 }
 
 static const struct udevice_id tc358870_ids[] = {
@@ -620,6 +763,8 @@ U_BOOT_DRIVER(toshiba_tc358870) = {
 	.name	= "toshiba_tc358870",
 	.id	= UCLASS_PANEL_DETECTOR,
 	.of_match = tc358870_ids,
+	.ops	= &tc358870_ops,
 	.probe	= tc358870_probe,
+	.remove = tc358870_remove,
 	.priv_auto_alloc_size = sizeof(struct tc358870_priv),
 };
-- 
2.30.1

